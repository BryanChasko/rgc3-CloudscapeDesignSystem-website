import {
  useDebounceCallback
} from "./chunk-Y3T7CXFH.js";
import {
  FunnelContext,
  FunnelMetrics,
  FunnelStepContext,
  FunnelSubStepContext,
  nodeBelongs,
  useFunnel,
  useFunnelStep
} from "./chunk-GC32QG33.js";
import {
  DATA_ATTR_FUNNEL_STEP,
  getFunnelNameSelector,
  getNameFromSelector,
  getSubStepAllSelector,
  getSubStepNameSelector,
  getSubStepSelector
} from "./chunk-37SB7DJX.js";
import {
  useUniqueId
} from "./chunk-3TE4OIE4.js";
import {
  PACKAGE_VERSION,
  __awaiter,
  __rest,
  useVisualRefresh
} from "./chunk-CHBULPAM.js";
import {
  __toESM,
  require_react
} from "./chunk-S2TLTWWO.js";

// node_modules/@cloudscape-design/components/internal/analytics/components/analytics-funnel.js
var import_react = __toESM(require_react());
var FUNNEL_VERSION = "1.4";
var AnalyticsFunnel = (props) => {
  const { isInFunnel } = useFunnel();
  if (isInFunnel && props.funnelType === "single-page") {
    return import_react.default.createElement(import_react.default.Fragment, null, props.children);
  }
  return import_react.default.createElement(InnerAnalyticsFunnel, Object.assign({}, props));
};
var CREATION_EDIT_FLOW_DONE_EVENT_NAME = "awsui-creation-edit-flow-done";
var dispatchCreateEditFlowDoneEvent = () => {
  var _a;
  try {
    (_a = window.top) === null || _a === void 0 ? void 0 : _a.document.dispatchEvent(new Event(CREATION_EDIT_FLOW_DONE_EVENT_NAME));
  } catch (_b) {
  }
};
var onFunnelCancelled = ({ funnelInteractionId }) => {
  FunnelMetrics.funnelCancelled({ funnelInteractionId });
};
var onFunnelComplete = ({ funnelInteractionId }) => {
  FunnelMetrics.funnelComplete({ funnelInteractionId });
  dispatchCreateEditFlowDoneEvent();
};
function evaluateSelectors(selectors, defaultSelector) {
  for (const selector of selectors) {
    const element = document.querySelector(selector);
    if (element) {
      return selector;
    }
  }
  return defaultSelector;
}
var InnerAnalyticsFunnel = (_a) => {
  var { children, stepConfiguration } = _a, props = __rest(_a, ["children", "stepConfiguration"]);
  const [funnelInteractionId, setFunnelInteractionId] = (0, import_react.useState)("");
  const [submissionAttempt, setSubmissionAttempt] = (0, import_react.useState)(0);
  const isVisualRefresh = useVisualRefresh();
  const funnelState = (0, import_react.useRef)("default");
  const funnelNameSelector = (0, import_react.useRef)(getFunnelNameSelector());
  const errorCount = (0, import_react.useRef)(0);
  const loadingButtonCount = (0, import_react.useRef)(0);
  const wizardCount = (0, import_react.useRef)(0);
  const latestFocusCleanupFunction = (0, import_react.useRef)(void 0);
  (0, import_react.useEffect)(() => {
    let funnelInteractionId2;
    const handle = setTimeout(() => {
      var _a2;
      funnelNameSelector.current = evaluateSelectors(props.funnelNameSelectors || [], getFunnelNameSelector());
      if (props.funnelType === "single-page" && wizardCount.current > 0) {
        return;
      }
      funnelState.current = "default";
      const singleStepFlowStepConfiguration = [
        { number: 1, isOptional: false, name: (_a2 = getNameFromSelector(funnelNameSelector.current)) !== null && _a2 !== void 0 ? _a2 : "" }
      ];
      funnelInteractionId2 = FunnelMetrics.funnelStart({
        funnelNameSelector: funnelNameSelector.current,
        optionalStepNumbers: props.optionalStepNumbers,
        funnelType: props.funnelType,
        totalFunnelSteps: props.totalFunnelSteps,
        componentVersion: PACKAGE_VERSION,
        theme: isVisualRefresh ? "vr" : "classic",
        funnelVersion: FUNNEL_VERSION,
        stepConfiguration: stepConfiguration !== null && stepConfiguration !== void 0 ? stepConfiguration : singleStepFlowStepConfiguration
      });
      setFunnelInteractionId(funnelInteractionId2);
    }, 1);
    return () => {
      clearTimeout(handle);
      if (props.funnelType === "single-page" && wizardCount.current > 0) {
        return;
      }
      if (funnelState.current === "validating") {
        onFunnelComplete({ funnelInteractionId: funnelInteractionId2 });
        funnelState.current = "complete";
      }
      if (funnelState.current === "complete") {
        FunnelMetrics.funnelSuccessful({ funnelInteractionId: funnelInteractionId2 });
      } else {
        onFunnelCancelled({ funnelInteractionId: funnelInteractionId2 });
        funnelState.current = "cancelled";
      }
    };
  }, []);
  const funnelSubmit = () => {
    funnelState.current = "validating";
    const VALIDATION_WAIT_DELAY = 50;
    const LOADING_WAIT_DELAY = 100;
    const checkForCompleteness = () => {
      if (funnelState.current === "complete") {
        return;
      }
      if (loadingButtonCount.current > 0) {
        setTimeout(checkForCompleteness, LOADING_WAIT_DELAY);
        return;
      }
      if (errorCount.current === 0) {
        onFunnelComplete({ funnelInteractionId });
        funnelState.current = "complete";
      } else {
        funnelState.current = "default";
      }
    };
    setTimeout(checkForCompleteness, VALIDATION_WAIT_DELAY);
  };
  const funnelNextOrSubmitAttempt = () => setSubmissionAttempt((i) => i + 1);
  const funnelCancel = () => {
  };
  const funnelContextValue = {
    funnelInteractionId,
    setFunnelInteractionId,
    funnelType: props.funnelType,
    optionalStepNumbers: props.optionalStepNumbers,
    totalFunnelSteps: props.totalFunnelSteps,
    funnelNameSelector: funnelNameSelector.current,
    funnelSubmit,
    funnelCancel,
    submissionAttempt,
    funnelNextOrSubmitAttempt,
    funnelState,
    errorCount,
    loadingButtonCount,
    latestFocusCleanupFunction,
    isInFunnel: true,
    wizardCount
  };
  return import_react.default.createElement(FunnelContext.Provider, { value: funnelContextValue }, children);
};
var AnalyticsFunnelStep = (props) => {
  return import_react.default.createElement(InnerAnalyticsFunnelStep, Object.assign({}, props, { key: props.stepNumber }));
};
function getSubStepConfiguration() {
  const subSteps = Array.from(document.querySelectorAll(getSubStepAllSelector()));
  const subStepConfiguration = subSteps.map((substep, index) => {
    var _a, _b, _c;
    const name = (_c = (_b = (_a = substep.querySelector(getSubStepNameSelector())) === null || _a === void 0 ? void 0 : _a.innerText) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "";
    return {
      name,
      number: index + 1
    };
  });
  return subStepConfiguration;
}
function useStepChangeListener(stepNumber, handler) {
  const subStepConfiguration = (0, import_react.useRef)(/* @__PURE__ */ new Map());
  const SUBSTEP_CHANGE_DEBOUNCE = 50;
  const listenForSubStepChanges = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    const handle = setTimeout(() => listenForSubStepChanges.current = true, SUBSTEP_CHANGE_DEBOUNCE);
    return () => {
      clearTimeout(handle);
      listenForSubStepChanges.current = false;
    };
  }, []);
  (0, import_react.useEffect)(() => {
    const handle = setTimeout(() => subStepConfiguration.current.set(stepNumber, getSubStepConfiguration()), SUBSTEP_CHANGE_DEBOUNCE);
    return () => {
      clearTimeout(handle);
    };
  }, [stepNumber]);
  const stepChangeCallback = useDebounceCallback(() => {
    if (!listenForSubStepChanges.current) {
      return;
    }
    subStepConfiguration.current.set(stepNumber, getSubStepConfiguration());
    handler(subStepConfiguration.current.get(stepNumber));
  }, SUBSTEP_CHANGE_DEBOUNCE);
  return { onStepChange: stepChangeCallback, subStepConfiguration };
}
var InnerAnalyticsFunnelStep = (_a) => {
  var { children, stepNumber } = _a, rest = __rest(_a, ["children", "stepNumber"]);
  const { funnelInteractionId, funnelNameSelector, funnelState, funnelType } = useFunnel();
  const parentStep = useFunnelStep();
  const parentStepExists = parentStep.isInStep;
  const parentStepFunnelInteractionId = parentStep.funnelInteractionId;
  const funnelStepProps = { [DATA_ATTR_FUNNEL_STEP]: stepNumber };
  const subStepCount = (0, import_react.useRef)(0);
  const stepNameSelector = rest.stepNameSelector || funnelNameSelector;
  const { onStepChange, subStepConfiguration } = useStepChangeListener(stepNumber, (subStepConfiguration2) => {
    var _a2;
    if (!funnelInteractionId) {
      return;
    }
    const stepName = (_a2 = getNameFromSelector(stepNameSelector)) !== null && _a2 !== void 0 ? _a2 : "";
    FunnelMetrics.funnelStepChange({
      funnelInteractionId,
      stepNumber,
      stepName,
      stepNameSelector,
      subStepAllSelector: getSubStepAllSelector(),
      totalSubSteps: subStepCount.current,
      subStepConfiguration: subStepConfiguration2
    });
  });
  (0, import_react.useEffect)(() => {
    if (!funnelInteractionId) {
      return;
    }
    if (parentStepExists && parentStepFunnelInteractionId) {
      return;
    }
    const stepName = getNameFromSelector(stepNameSelector);
    if (funnelState.current === "default") {
      FunnelMetrics.funnelStepStart({
        funnelInteractionId,
        stepNumber,
        stepName,
        stepNameSelector,
        subStepAllSelector: getSubStepAllSelector(),
        totalSubSteps: subStepCount.current,
        subStepConfiguration: getSubStepConfiguration()
      });
    }
    return () => {
      if (funnelState.current !== "cancelled") {
        FunnelMetrics.funnelStepComplete({
          funnelInteractionId,
          stepNumber,
          stepName,
          stepNameSelector,
          subStepAllSelector: getSubStepAllSelector(),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          totalSubSteps: subStepCount.current
        });
      }
    };
  }, [
    funnelInteractionId,
    stepNumber,
    stepNameSelector,
    funnelState,
    parentStepExists,
    funnelType,
    parentStepFunnelInteractionId
  ]);
  const contextValue = {
    stepNumber,
    stepNameSelector,
    funnelStepProps,
    subStepCount,
    isInStep: true,
    funnelInteractionId,
    onStepChange,
    subStepConfiguration
  };
  const effectiveContextValue = parentStepExists && parentStepFunnelInteractionId ? parentStep : contextValue;
  return import_react.default.createElement(FunnelStepContext.Provider, { value: effectiveContextValue }, typeof children === "function" ? children(effectiveContextValue) : children);
};
var AnalyticsFunnelSubStep = ({ children }) => {
  const subStepId = useUniqueId("substep");
  const subStepSelector = getSubStepSelector(subStepId);
  const subStepNameSelector = getSubStepNameSelector(subStepId);
  const subStepRef = (0, import_react.useRef)(null);
  const { subStepCount, onStepChange } = useFunnelStep();
  const mousePressed = (0, import_react.useRef)(false);
  const isFocusedSubStep = (0, import_react.useRef)(false);
  const focusCleanupFunction = (0, import_react.useRef)(void 0);
  const { funnelState, funnelInteractionId } = useFunnel();
  const { stepNumber, stepNameSelector } = useFunnelStep();
  const newContext = {
    subStepSelector,
    subStepNameSelector,
    subStepId,
    subStepRef,
    mousePressed,
    isFocusedSubStep,
    focusCleanupFunction,
    isNestedSubStep: false
  };
  const inheritedContext = Object.assign(Object.assign({}, (0, import_react.useContext)(FunnelSubStepContext)), { isNestedSubStep: true });
  const isNested = Boolean(inheritedContext.subStepId);
  (0, import_react.useEffect)(() => {
    if (!isNested) {
      subStepCount.current++;
      onStepChange();
      return () => {
        subStepCount.current--;
        onStepChange();
      };
    }
  }, [isNested, subStepCount, onStepChange]);
  const context = isNested ? inheritedContext : newContext;
  (0, import_react.useEffect)(() => {
    if (isNested || !subStepRef.current) {
      return;
    }
    const onMouseDown = () => mousePressed.current = true;
    const onMouseUp = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a;
      mousePressed.current = false;
      if (!isFocusedSubStep.current) {
        return;
      }
      yield new Promise((r) => setTimeout(r, 1));
      if (!subStepRef.current || !document.activeElement || !nodeBelongs(subStepRef.current, document.activeElement)) {
        isFocusedSubStep.current = false;
        (_a = focusCleanupFunction.current) === null || _a === void 0 ? void 0 : _a.call(focusCleanupFunction);
      }
    });
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup", onMouseUp);
    return () => {
      window.removeEventListener("mousedown", onMouseDown);
      window.removeEventListener("mouseup", onMouseUp);
    };
  }, [
    funnelInteractionId,
    funnelState,
    stepNameSelector,
    stepNumber,
    subStepNameSelector,
    subStepSelector,
    focusCleanupFunction,
    isNested,
    subStepRef
  ]);
  return import_react.default.createElement(FunnelSubStepContext.Provider, { value: context }, typeof children === "function" ? children(context) : children);
};

export {
  AnalyticsFunnel,
  AnalyticsFunnelStep,
  AnalyticsFunnelSubStep
};
//# sourceMappingURL=chunk-6LZAGYP5.js.map
