import {
  usePrevious
} from "./chunk-U6AS5SDP.js";
import {
  StatusIndicator
} from "./chunk-A5NNEFWN.js";
import {
  internal_default as internal_default3
} from "./chunk-UU5H6V7V.js";
import {
  InternalSpaceBetween
} from "./chunk-BENPS2G5.js";
import {
  radio_button_default
} from "./chunk-GMWSECVM.js";
import {
  browserScrollbarSize
} from "./chunk-2DINTSCD.js";
import {
  CollectionLabelContext
} from "./chunk-XFXLI6GJ.js";
import {
  InternalFormField
} from "./chunk-2SJA3QXU.js";
import {
  joinStrings
} from "./chunk-KFGQ7LSZ.js";
import {
  InternalContainer
} from "./chunk-Z4NCSJKF.js";
import {
  StickyHeaderContext
} from "./chunk-GRT2X74T.js";
import {
  styles_css_default
} from "./chunk-PFKSO5SI.js";
import {
  LinkDefaultVariantContext
} from "./chunk-CGX6IJLX.js";
import {
  AnalyticsFunnelSubStep
} from "./chunk-6LZAGYP5.js";
import {
  useContainerBreakpoints
} from "./chunk-BESADZDS.js";
import {
  useDynamicOverlap
} from "./chunk-2AZBVB2W.js";
import {
  useAppLayoutContext
} from "./chunk-KGTDQHUA.js";
import {
  useContainerQuery
} from "./chunk-BQ3I4KFU.js";
import {
  getContentHeaderClassName
} from "./chunk-IRDBMKXJ.js";
import {
  arrow_default,
  useHiddenDescription
} from "./chunk-RO2Y45RE.js";
import {
  PopoverBody,
  PopoverContainer
} from "./chunk-7XRAASIL.js";
import {
  usePortalModeClasses
} from "./chunk-EYMPTN4Q.js";
import {
  Portal
} from "./chunk-TT4W3QW4.js";
import {
  focus_lock_default
} from "./chunk-WS7XJ5RY.js";
import {
  getAllFocusables
} from "./chunk-WYL2VUB3.js";
import {
  getOverflowParents,
  scrollElementIntoView,
  useMobile
} from "./chunk-4K34KLGB.js";
import {
  getVisualContextClassname
} from "./chunk-CG2QVKT3.js";
import {
  useInternalI18n
} from "./chunk-VCW6C342.js";
import {
  internal_default as internal_default2,
  usePerformanceMarks
} from "./chunk-DPGYCRGF.js";
import {
  ScreenreaderOnly,
  live_region_default
} from "./chunk-ESFEWRKR.js";
import {
  SingleTabStopNavigationContext,
  useSingleTabStopNavigation
} from "./chunk-KYLY6TIG.js";
import {
  fireCancelableEvent,
  fireNonCancelableEvent
} from "./chunk-T3BYYNEM.js";
import {
  nodeBelongs,
  useFunnelSubStep
} from "./chunk-GC32QG33.js";
import {
  findUpUntil as findUpUntil2,
  getContainingBlock,
  supportsStickyPosition
} from "./chunk-37SB7DJX.js";
import {
  useUniqueId
} from "./chunk-3TE4OIE4.js";
import {
  isDevelopment
} from "./chunk-TIE5RIC4.js";
import {
  internal_default
} from "./chunk-NUCDU4ZC.js";
import {
  useMergeRefs
} from "./chunk-NYW4WZSZ.js";
import {
  KeyCode,
  ResizeObserver,
  __awaiter,
  __rest,
  applyDisplayName,
  clsx_m_default,
  createSingletonHandler,
  findUpUntil,
  getBaseProps,
  useBaseComponent,
  useResizeObserver,
  useStableCallback,
  useVisualRefresh,
  warnOnce
} from "./chunk-CHBULPAM.js";
import {
  require_react_dom
} from "./chunk-MCEUSTYS.js";
import {
  __toESM,
  require_react
} from "./chunk-S2TLTWWO.js";

// node_modules/@cloudscape-design/components/table/index.js
var import_react28 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/internal.js
var import_react27 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/tools-header.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/styles.css.js
import "/home/bryanchasko/code/rgc3/node_modules/@cloudscape-design/components/table/styles.scoped.css";
var styles_css_default2 = {
  "root": "awsui_root_wih1l_qzfuf_103",
  "tools": "awsui_tools_wih1l_qzfuf_114",
  "tools-filtering": "awsui_tools-filtering_wih1l_qzfuf_122",
  "tools-align-right": "awsui_tools-align-right_wih1l_qzfuf_136",
  "tools-pagination": "awsui_tools-pagination_wih1l_qzfuf_140",
  "tools-preferences": "awsui_tools-preferences_wih1l_qzfuf_140",
  "tools-small": "awsui_tools-small_wih1l_qzfuf_146",
  "table": "awsui_table_wih1l_qzfuf_152",
  "table-layout-fixed": "awsui_table-layout-fixed_wih1l_qzfuf_158",
  "wrapper": "awsui_wrapper_wih1l_qzfuf_162",
  "variant-stacked": "awsui_variant-stacked_wih1l_qzfuf_169",
  "wrapper-content-measure": "awsui_wrapper-content-measure_wih1l_qzfuf_169",
  "variant-container": "awsui_variant-container_wih1l_qzfuf_169",
  "has-footer": "awsui_has-footer_wih1l_qzfuf_172",
  "has-header": "awsui_has-header_wih1l_qzfuf_175",
  "cell-merged": "awsui_cell-merged_wih1l_qzfuf_192",
  "cell-merged-content": "awsui_cell-merged-content_wih1l_qzfuf_204",
  "empty": "awsui_empty_wih1l_qzfuf_222",
  "loading": "awsui_loading_wih1l_qzfuf_226",
  "selection-control": "awsui_selection-control_wih1l_qzfuf_235",
  "selection-control-header": "awsui_selection-control-header_wih1l_qzfuf_242",
  "dark-header": "awsui_dark-header_wih1l_qzfuf_252",
  "header-secondary": "awsui_header-secondary_wih1l_qzfuf_257",
  "table-has-header": "awsui_table-has-header_wih1l_qzfuf_275",
  "header-controls": "awsui_header-controls_wih1l_qzfuf_279",
  "variant-full-page": "awsui_variant-full-page_wih1l_qzfuf_282",
  "variant-embedded": "awsui_variant-embedded_wih1l_qzfuf_288",
  "variant-borderless": "awsui_variant-borderless_wih1l_qzfuf_288",
  "footer-wrapper": "awsui_footer-wrapper_wih1l_qzfuf_293",
  "footer": "awsui_footer_wih1l_qzfuf_293",
  "footer-with-pagination": "awsui_footer-with-pagination_wih1l_qzfuf_301",
  "footer-pagination": "awsui_footer-pagination_wih1l_qzfuf_309",
  "thead-active": "awsui_thead-active_wih1l_qzfuf_313",
  "row": "awsui_row_wih1l_qzfuf_314",
  "row-selected": "awsui_row-selected_wih1l_qzfuf_315"
};

// node_modules/@cloudscape-design/components/table/tools-header.js
function ToolsHeader({ header, filter, pagination, preferences }) {
  const [breakpoint, ref] = useContainerBreakpoints(["xs"]);
  const isHeaderString = typeof header === "string";
  const assignHeaderId = (0, import_react.useContext)(CollectionLabelContext).assignId;
  const headingId = useUniqueId("heading");
  if (assignHeaderId !== void 0 && isHeaderString) {
    assignHeaderId(headingId);
  }
  const isSmall = breakpoint === "default";
  const hasTools = filter || pagination || preferences;
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    isHeaderString ? import_react.default.createElement("span", { id: headingId }, header) : header,
    hasTools && import_react.default.createElement(
      "div",
      { ref, className: clsx_m_default(styles_css_default2.tools, isSmall && styles_css_default2["tools-small"]) },
      filter && import_react.default.createElement("div", { className: styles_css_default2["tools-filtering"] }, filter),
      import_react.default.createElement(
        "div",
        { className: styles_css_default2["tools-align-right"] },
        pagination && import_react.default.createElement("div", { className: styles_css_default2["tools-pagination"] }, pagination),
        preferences && import_react.default.createElement("div", { className: styles_css_default2["tools-preferences"] }, preferences)
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/thead.js
var import_react12 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/selection/selection-control.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/selection/styles.css.js
import "/home/bryanchasko/code/rgc3/node_modules/@cloudscape-design/components/table/selection/styles.scoped.css";
var styles_css_default3 = {
  "root": "awsui_root_1s55x_d36ci_99",
  "label": "awsui_label_1s55x_d36ci_103",
  "stud": "awsui_stud_1s55x_d36ci_117"
};

// node_modules/@cloudscape-design/components/table/selection/selection-control.js
function SelectionControl(_a) {
  var { tableRole, selectionType, indeterminate = false, onShiftToggle, onFocusUp, onFocusDown, name, ariaLabel, focusedComponent } = _a, sharedProps = __rest(_a, ["tableRole", "selectionType", "indeterminate", "onShiftToggle", "onFocusUp", "onFocusDown", "name", "ariaLabel", "focusedComponent"]);
  const controlId = useUniqueId();
  const isMultiSelection = selectionType === "multi";
  const setShiftState = (event) => {
    if (isMultiSelection) {
      onShiftToggle && onShiftToggle(event.shiftKey);
    }
  };
  const onMouseDownHandler = (event) => {
    setShiftState(event);
    if (isMultiSelection) {
      event.preventDefault();
    }
  };
  const handleKeyDown = (event) => {
    setShiftState(event);
    if (isMultiSelection && tableRole !== "grid") {
      if (event.keyCode === KeyCode.up) {
        event.preventDefault();
        onFocusUp && onFocusUp(event);
      }
      if (event.keyCode === KeyCode.down) {
        event.preventDefault();
        onFocusDown && onFocusDown(event);
      }
    }
  };
  const handleClick = (event) => {
    const target = event.currentTarget;
    const nativeInput = target.tagName === "INPUT" ? target : target.querySelector("input");
    nativeInput === null || nativeInput === void 0 ? void 0 : nativeInput.focus();
  };
  const selector = isMultiSelection ? import_react2.default.createElement(internal_default3, Object.assign({}, sharedProps, { showOutline: focusedComponent === "selection-control", controlId, "data-focus-id": "selection-control", indeterminate })) : import_react2.default.createElement(radio_button_default, Object.assign({}, sharedProps, { controlId, name, value: "", label: "" }));
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement("label", { onKeyDown: handleKeyDown, onKeyUp: setShiftState, onMouseDown: onMouseDownHandler, onMouseUp: setShiftState, onClick: handleClick, htmlFor: controlId, className: clsx_m_default(styles_css_default3.label, styles_css_default3.root), "aria-label": ariaLabel, title: ariaLabel }, selector),
    import_react2.default.createElement("span", { className: clsx_m_default(styles_css_default3.stud), "aria-hidden": true }, "Â ")
  );
}

// node_modules/@cloudscape-design/components/table/utils.js
var applyTrackBy = (trackBy, item) => {
  if (typeof trackBy === "function") {
    return trackBy(item);
  }
  return item[trackBy];
};
var getItemKey = (trackBy, item, index) => {
  if (!trackBy) {
    return index;
  }
  return applyTrackBy(trackBy, item);
};
var getTrackableValue = (trackBy, item) => {
  if (!trackBy) {
    return item;
  }
  return applyTrackBy(trackBy, item);
};
var getColumnKey = (column, index) => {
  return column.id || index;
};
var toContainerVariant = (variant) => {
  const isDefaultVariant = !variant || variant === "container";
  return isDefaultVariant ? "default" : variant === "borderless" ? "embedded" : variant;
};
function checkSortingState(columnDefinitions, sortingComparator) {
  const matchedColumn = columnDefinitions.filter((column) => column.sortingComparator === sortingComparator)[0];
  if (!matchedColumn) {
    warnOnce("Table", "Currently active sorting comparator was not found in any columns. Make sure to provide the same comparator function instance on each render.");
  }
}
function getVisibleColumnDefinitions({ columnDisplay, visibleColumns, columnDefinitions }) {
  if (columnDisplay) {
    return getVisibleColumnDefinitionsFromColumnDisplay({ columnDisplay, columnDefinitions });
  } else if (visibleColumns) {
    return getVisibleColumnDefinitionsFromVisibleColumns({ visibleColumns, columnDefinitions });
  } else {
    return columnDefinitions;
  }
}
function getVisibleColumnDefinitionsFromColumnDisplay({ columnDisplay, columnDefinitions }) {
  const columnDefinitionsById = columnDefinitions.reduce((accumulator, item) => item.id === void 0 ? accumulator : Object.assign(Object.assign({}, accumulator), { [item.id]: item }), {});
  return columnDisplay.filter((item) => item.visible).map((item) => columnDefinitionsById[item.id]).filter(Boolean);
}
function getVisibleColumnDefinitionsFromVisibleColumns({ visibleColumns, columnDefinitions }) {
  const ids = new Set(visibleColumns);
  return columnDefinitions.filter(({ id }) => id !== void 0 && ids.has(id));
}
function getStickyClassNames(styles, props) {
  return {
    [styles["sticky-cell"]]: !!props,
    [styles["sticky-cell-pad-left"]]: !!(props === null || props === void 0 ? void 0 : props.padLeft),
    [styles["sticky-cell-last-left"]]: !!(props === null || props === void 0 ? void 0 : props.lastLeft),
    [styles["sticky-cell-last-right"]]: !!(props === null || props === void 0 ? void 0 : props.lastRight)
  };
}

// node_modules/@cloudscape-design/components/table/selection/utils.js
var SELECTION_ITEM = "selection-item";
var SELECTION_ROOT = "selection-root";
var ItemSet = class {
  constructor(trackBy, items) {
    this.map = /* @__PURE__ */ new Map();
    this.put = (item) => this.map.set.call(this.map, getTrackableValue(this.trackBy, item), item);
    this.has = (item) => this.map.has.call(this.map, getTrackableValue(this.trackBy, item));
    this.forEach = this.map.forEach.bind(this.map);
    this.trackBy = trackBy;
    items.forEach(this.put);
  }
};
var focusMarkers = {
  item: { ["data-" + SELECTION_ITEM]: "item" },
  all: { ["data-" + SELECTION_ITEM]: "all" },
  root: { ["data-" + SELECTION_ROOT]: "true" }
};

// node_modules/@cloudscape-design/components/table/selection/use-selection-focus-move.js
function useSelectionFocusMove(selectionType, totalItems) {
  if (selectionType !== "multi") {
    return {};
  }
  function moveFocus(sourceElement, fromIndex, direction) {
    let index = fromIndex;
    const rootContainer = findRootContainer(sourceElement);
    while (index >= -1 && index < totalItems) {
      index += direction;
      const control = findSelectionControlByIndex(rootContainer, index);
      if (control && !control.disabled) {
        control.focus();
        break;
      }
    }
  }
  const [moveFocusDown, moveFocusUp] = [1, -1].map((direction) => {
    return (event) => {
      const target = event.currentTarget;
      const itemNode = findUpUntil2(target, (node) => node.dataset.selectionItem === "item");
      const fromIndex = Array.prototype.indexOf.call(itemNode.parentElement.children, itemNode);
      moveFocus(target, fromIndex, direction);
    };
  });
  return {
    moveFocusDown,
    moveFocusUp,
    moveFocus
  };
}
function findSelectionControlByIndex(rootContainer, index) {
  if (index === -1) {
    return rootContainer.querySelector(`[data-${SELECTION_ITEM}="all"] .${styles_css_default3.root} input`);
  }
  return rootContainer.querySelectorAll(`[data-${SELECTION_ITEM}="item"] .${styles_css_default3.root} input`)[index];
}
function findRootContainer(element) {
  return findUpUntil2(element, (node) => node.dataset.selectionRoot === "true");
}

// node_modules/@cloudscape-design/components/table/selection/use-selection.js
var import_react3 = __toESM(require_react());
function useSelection({ items, selectedItems = [], selectionType, isItemDisabled = () => false, trackBy, onSelectionChange, ariaLabels, loading }) {
  const [shiftPressed, setShiftPressed] = (0, import_react3.useState)(false);
  const [lastClickedItem, setLastClickedItem] = (0, import_react3.useState)(null);
  const selectionName = useUniqueId();
  const finalSelectedItems = selectionType === "single" ? selectedItems.slice(0, 1) : selectedItems;
  const selectedSet = new ItemSet(trackBy, finalSelectedItems);
  const itemIndexesMap = /* @__PURE__ */ new Map();
  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));
  const isItemSelected = selectedSet.has.bind(selectedSet);
  const getItemState = (item) => ({
    disabled: isItemDisabled(item),
    selected: isItemSelected(item)
  });
  const [allDisabled, allEnabledSelected] = selectionType ? items.reduce(([allDisabled2, allEnabledSelected2], item) => {
    const { disabled, selected } = getItemState(item);
    return [
      // all items are disabled (or none are present)
      allDisabled2 && disabled,
      // all enabled items are selected (or none are present)
      allEnabledSelected2 && (selected || disabled)
    ];
  }, [true, true]) : [true, true];
  const hasSelected = finalSelectedItems.length > 0;
  const handleToggleAll = () => {
    const requestedItems = new ItemSet(trackBy, items);
    const newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);
    fireNonCancelableEvent(onSelectionChange, { selectedItems: newSelectedItems });
  };
  const getRequestedItems = (item) => {
    const requestedItems = new ItemSet(trackBy, [item]);
    let lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;
    if (lastClickedItemIndex === void 0) {
      lastClickedItemIndex = -1;
    }
    if (shiftPressed && lastClickedItemIndex !== -1) {
      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));
      const start = Math.min(currentItemIndex, lastClickedItemIndex);
      const end = Math.max(currentItemIndex, lastClickedItemIndex);
      items.slice(start, end + 1).forEach((item2) => requestedItems.put(item2));
    }
    return requestedItems;
  };
  const deselectItems = (requestedItems) => {
    const newSelectedItems = [];
    selectedItems.forEach((selectedItem) => {
      const toUnselect = requestedItems.has(selectedItem);
      if (!toUnselect || isItemDisabled(selectedItem)) {
        newSelectedItems.push(selectedItem);
      }
    });
    return newSelectedItems;
  };
  const selectItems = (requestedItems) => {
    const newSelectedItems = [...selectedItems];
    requestedItems.forEach((newItem) => {
      const { selected, disabled } = getItemState(newItem);
      if (!selected && !disabled) {
        newSelectedItems.push(newItem);
      }
    });
    return newSelectedItems;
  };
  const handleToggleItem = (item) => () => {
    const { disabled, selected } = getItemState(item);
    if (disabled || selectionType === "single" && selected) {
      return;
    }
    if (selectionType === "single") {
      fireNonCancelableEvent(onSelectionChange, { selectedItems: [item] });
    } else {
      const requestedItems = getRequestedItems(item);
      const selectedItems2 = selected ? deselectItems(requestedItems) : selectItems(requestedItems);
      fireNonCancelableEvent(onSelectionChange, { selectedItems: selectedItems2 });
      setLastClickedItem(item);
    }
  };
  return {
    isItemSelected,
    getSelectAllProps: () => {
      var _a;
      if (!selectionType) {
        throw new Error("Invariant violation: calling selection props with missing selection type.");
      }
      return {
        name: selectionName,
        disabled: allDisabled || !!loading,
        selectionType,
        indeterminate: hasSelected && !allEnabledSelected,
        checked: hasSelected && allEnabledSelected,
        onChange: handleToggleAll,
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems }))
      };
    },
    getItemSelectionProps: (item) => {
      var _a;
      if (!selectionType) {
        throw new Error("Invariant violation: calling selection props with missing selection type.");
      }
      return {
        name: selectionName,
        selectionType,
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems }, item)),
        onChange: handleToggleItem(item),
        checked: isItemSelected(item),
        disabled: isItemDisabled(item)
      };
    },
    updateShiftToggle: (value) => {
      setShiftPressed(value);
    }
  };
}

// node_modules/@cloudscape-design/components/table/header-cell/index.js
var import_react11 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/header-cell/utils.js
var stateToIcon = {
  sortable: "caret-down",
  ascending: "caret-up-filled",
  descending: "caret-down-filled"
};
var getSortingStatus = (sortable, sorted, descending, disabled) => {
  if (sorted) {
    if (descending) {
      return "descending";
    }
    return "ascending";
  }
  if (sortable && !disabled) {
    return "sortable";
  }
  return void 0;
};
var getSortingIconName = (sortingState) => stateToIcon[sortingState];
var isSorted = (column, sortingColumn) => column === sortingColumn || column.sortingField !== void 0 && column.sortingField === sortingColumn.sortingField || column.sortingComparator !== void 0 && column.sortingComparator === sortingColumn.sortingComparator;

// node_modules/@cloudscape-design/components/table/header-cell/styles.css.js
import "/home/bryanchasko/code/rgc3/node_modules/@cloudscape-design/components/table/header-cell/styles.scoped.css";
var styles_css_default4 = {
  "header-cell": "awsui_header-cell_1spae_1xk01_99",
  "header-cell-fake-focus": "awsui_header-cell-fake-focus_1spae_1xk01_133",
  "header-cell-sticky": "awsui_header-cell-sticky_1spae_1xk01_154",
  "header-cell-stuck": "awsui_header-cell-stuck_1spae_1xk01_157",
  "header-cell-variant-full-page": "awsui_header-cell-variant-full-page_1spae_1xk01_157",
  "header-cell-hidden": "awsui_header-cell-hidden_1spae_1xk01_160",
  "header-cell-sortable": "awsui_header-cell-sortable_1spae_1xk01_163",
  "sticky-cell": "awsui_sticky-cell_1spae_1xk01_166",
  "sticky-cell-pad-left": "awsui_sticky-cell-pad-left_1spae_1xk01_174",
  "has-selection": "awsui_has-selection_1spae_1xk01_174",
  "sticky-cell-last-left": "awsui_sticky-cell-last-left_1spae_1xk01_177",
  "resize-divider": "awsui_resize-divider_1spae_1xk01_181",
  "sticky-cell-last-right": "awsui_sticky-cell-last-right_1spae_1xk01_184",
  "sorting-icon": "awsui_sorting-icon_1spae_1xk01_199",
  "edit-icon": "awsui_edit-icon_1spae_1xk01_207",
  "header-cell-content": "awsui_header-cell-content_1spae_1xk01_213",
  "header-cell-disabled": "awsui_header-cell-disabled_1spae_1xk01_267",
  "header-cell-sorted": "awsui_header-cell-sorted_1spae_1xk01_267",
  "header-cell-text": "awsui_header-cell-text_1spae_1xk01_281",
  "header-cell-text-wrap": "awsui_header-cell-text-wrap_1spae_1xk01_285",
  "header-cell-ascending": "awsui_header-cell-ascending_1spae_1xk01_291",
  "header-cell-descending": "awsui_header-cell-descending_1spae_1xk01_292",
  "is-visual-refresh": "awsui_is-visual-refresh_1spae_1xk01_302",
  "has-striped-rows": "awsui_has-striped-rows_1spae_1xk01_313"
};

// node_modules/@cloudscape-design/components/table/resizer/index.js
var import_react5 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/resizer/styles.css.js
import "/home/bryanchasko/code/rgc3/node_modules/@cloudscape-design/components/table/resizer/styles.scoped.css";
var styles_css_default5 = {
  "resize-active": "awsui_resize-active_x7peu_sqn6e_99",
  "resize-active-with-focus": "awsui_resize-active-with-focus_x7peu_sqn6e_99",
  "divider": "awsui_divider_x7peu_sqn6e_104",
  "divider-disabled": "awsui_divider-disabled_x7peu_sqn6e_118",
  "divider-active": "awsui_divider-active_x7peu_sqn6e_121",
  "resizer": "awsui_resizer_x7peu_sqn6e_125",
  "has-focus": "awsui_has-focus_x7peu_sqn6e_182",
  "tracker": "awsui_tracker_x7peu_sqn6e_205"
};

// node_modules/@cloudscape-design/components/table/use-column-widths.js
var import_react4 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/column-widths-utils.js
function checkColumnWidths(columnDefinitions) {
  for (const column of columnDefinitions) {
    checkProperty(column, "minWidth");
    checkProperty(column, "width");
  }
}
function setElementWidths(element, styles) {
  function setProperty(property) {
    const value = styles[property];
    let widthCssValue = "";
    if (typeof value === "number") {
      widthCssValue = value + "px";
    }
    if (typeof value === "string") {
      widthCssValue = value;
    }
    if (element.style[property] !== widthCssValue) {
      element.style[property] = widthCssValue;
    }
  }
  setProperty("width");
  setProperty("minWidth");
  setProperty("maxWidth");
}
function checkProperty(column, name) {
  const value = column[name];
  if (typeof value !== "number" && typeof value !== "undefined") {
    warnOnce("Table", `resizableColumns feature requires ${name} property to be a number, got ${value}. The component may work incorrectly.`);
  }
}

// node_modules/@cloudscape-design/components/table/use-column-widths.js
var DEFAULT_COLUMN_WIDTH = 120;
function readWidths(getCell, visibleColumns) {
  var _a;
  const result = /* @__PURE__ */ new Map();
  for (let index = 0; index < visibleColumns.length; index++) {
    const column = visibleColumns[index];
    let width = column.width || 0;
    const minWidth = column.minWidth || width || DEFAULT_COLUMN_WIDTH;
    if (!width && // read width from the DOM if it is missing in the config
    index !== visibleColumns.length - 1) {
      const colEl = getCell(column.id);
      width = (_a = colEl === null || colEl === void 0 ? void 0 : colEl.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : DEFAULT_COLUMN_WIDTH;
    }
    result.set(column.id, Math.max(width, minWidth));
  }
  return result;
}
function updateWidths(visibleColumns, oldWidths, newWidth, columnId) {
  const column = visibleColumns.find((column2) => column2.id === columnId);
  const minWidth = typeof (column === null || column === void 0 ? void 0 : column.minWidth) === "number" ? column.minWidth : DEFAULT_COLUMN_WIDTH;
  newWidth = Math.max(newWidth, minWidth);
  if (oldWidths.get(columnId) === newWidth) {
    return oldWidths;
  }
  const newWidths = new Map(oldWidths);
  newWidths.set(columnId, newWidth);
  return newWidths;
}
var WidthsContext = (0, import_react4.createContext)({
  getColumnStyles: () => ({}),
  columnWidths: /* @__PURE__ */ new Map(),
  updateColumn: () => {
  },
  setCell: () => {
  }
});
function ColumnWidthsProvider({ visibleColumns, resizableColumns, containerRef, children }) {
  const visibleColumnsRef = (0, import_react4.useRef)(null);
  const containerWidthRef = (0, import_react4.useRef)(0);
  const [columnWidths, setColumnWidths] = (0, import_react4.useState)(null);
  const cellsRef = (0, import_react4.useRef)(/* @__PURE__ */ new Map());
  const stickyCellsRef = (0, import_react4.useRef)(/* @__PURE__ */ new Map());
  const getCell = (columnId) => {
    var _a;
    return (_a = cellsRef.current.get(columnId)) !== null && _a !== void 0 ? _a : null;
  };
  const setCell = (sticky, columnId, node) => {
    const ref = sticky ? stickyCellsRef : cellsRef;
    if (node) {
      ref.current.set(columnId, node);
    } else {
      ref.current.delete(columnId);
    }
  };
  const getColumnStyles = (sticky, columnId) => {
    var _a, _b, _c;
    const column = visibleColumns.find((column2) => column2.id === columnId);
    if (!column) {
      return {};
    }
    if (sticky) {
      return { width: ((_a = cellsRef.current.get(column.id)) === null || _a === void 0 ? void 0 : _a.offsetWidth) || ((_b = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.get(column.id)) !== null && _b !== void 0 ? _b : column.width) };
    }
    if (resizableColumns && columnWidths) {
      const isLastColumn = column.id === ((_c = visibleColumns[visibleColumns.length - 1]) === null || _c === void 0 ? void 0 : _c.id);
      const totalWidth = visibleColumns.reduce((sum, { id }) => sum + (columnWidths.get(id) || DEFAULT_COLUMN_WIDTH), 0);
      if (isLastColumn && containerWidthRef.current > totalWidth) {
        return { width: "auto", minWidth: column === null || column === void 0 ? void 0 : column.minWidth };
      } else {
        return { width: columnWidths.get(column.id), minWidth: column === null || column === void 0 ? void 0 : column.minWidth };
      }
    }
    return {
      width: column.width,
      minWidth: column.minWidth,
      maxWidth: !resizableColumns ? column.maxWidth : void 0
    };
  };
  const updateColumnWidths = useStableCallback(() => {
    for (const { id } of visibleColumns) {
      const element = cellsRef.current.get(id);
      if (element) {
        setElementWidths(element, getColumnStyles(false, id));
      }
    }
    for (const { id } of visibleColumns) {
      const element = stickyCellsRef.current.get(id);
      if (element) {
        setElementWidths(element, getColumnStyles(true, id));
      }
    }
  });
  useResizeObserver(containerRef, ({ contentBoxWidth: containerWidth }) => {
    containerWidthRef.current = containerWidth;
    updateColumnWidths();
  });
  (0, import_react4.useEffect)(() => {
    updateColumnWidths();
    if (!resizableColumns) {
      return;
    }
    let updated = false;
    const newColumnWidths = new Map(columnWidths);
    const lastVisible = visibleColumnsRef.current;
    if (lastVisible) {
      for (let index = 0; index < visibleColumns.length; index++) {
        const column = visibleColumns[index];
        if (!(columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.get(column.id)) && lastVisible.indexOf(column.id) === -1) {
          updated = true;
          newColumnWidths.set(column.id, column.width || DEFAULT_COLUMN_WIDTH);
        }
      }
      if (updated) {
        setColumnWidths(newColumnWidths);
      }
    }
    visibleColumnsRef.current = visibleColumns.map((column) => column.id);
  }, [columnWidths, resizableColumns, visibleColumns, updateColumnWidths]);
  (0, import_react4.useEffect)(() => {
    if (!resizableColumns) {
      return;
    }
    setColumnWidths(() => readWidths(getCell, visibleColumns));
  }, []);
  function updateColumn(columnId, newWidth) {
    setColumnWidths((columnWidths2) => updateWidths(visibleColumns, columnWidths2 !== null && columnWidths2 !== void 0 ? columnWidths2 : /* @__PURE__ */ new Map(), newWidth, columnId));
  }
  return import_react4.default.createElement(WidthsContext.Provider, { value: { getColumnStyles, columnWidths: columnWidths !== null && columnWidths !== void 0 ? columnWidths : /* @__PURE__ */ new Map(), updateColumn, setCell } }, children);
}
function useColumnWidths() {
  return (0, import_react4.useContext)(WidthsContext);
}

// node_modules/@cloudscape-design/components/table/resizer/resizer-lookup.js
function getResizerElements(resizerElement) {
  if (!resizerElement) {
    return null;
  }
  const header = findUpUntil(resizerElement, (element) => element.tagName.toLowerCase() === "th");
  if (!header) {
    return null;
  }
  const tableRoot = findUpUntil(header, (element) => element.className.indexOf(styles_css_default2.root) > -1);
  if (!tableRoot) {
    return null;
  }
  const table = tableRoot.querySelector(`table`);
  if (!table) {
    return null;
  }
  const tracker = tableRoot.querySelector(`.${styles_css_default5.tracker}`);
  if (!tracker) {
    return null;
  }
  const scrollParent = getOverflowParents(header)[0];
  if (!scrollParent) {
    return null;
  }
  return { header, table, tracker, scrollParent };
}
function getHeaderWidth(resizerElement) {
  var _a;
  const header = resizerElement && findUpUntil(resizerElement, (element) => element.tagName.toLowerCase() === "th");
  return (_a = header === null || header === void 0 ? void 0 : header.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : 0;
}

// node_modules/@cloudscape-design/components/table/resizer/index.js
var AUTO_GROW_START_TIME = 10;
var AUTO_GROW_INTERVAL = 10;
var AUTO_GROW_INCREMENT = 5;
function Divider({ className }) {
  return import_react5.default.createElement("span", { className: clsx_m_default(styles_css_default5.divider, styles_css_default5["divider-disabled"], className) });
}
function Resizer({ onWidthUpdate, onWidthUpdateCommit, ariaLabelledby, minWidth = DEFAULT_COLUMN_WIDTH, tabIndex, showFocusRing, focusId, roleDescription }) {
  onWidthUpdate = useStableCallback(onWidthUpdate);
  onWidthUpdateCommit = useStableCallback(onWidthUpdateCommit);
  const separatorId = useUniqueId();
  const resizerToggleRef = (0, import_react5.useRef)(null);
  const resizerSeparatorRef = (0, import_react5.useRef)(null);
  const [isDragging, setIsDragging] = (0, import_react5.useState)(false);
  const [isKeyboardDragging, setIsKeyboardDragging] = (0, import_react5.useState)(false);
  const autoGrowTimeout = (0, import_react5.useRef)();
  const [resizerHasFocus, setResizerHasFocus] = (0, import_react5.useState)(false);
  const [headerCellWidth, setHeaderCellWidth] = (0, import_react5.useState)(0);
  (0, import_react5.useEffect)(() => {
    setHeaderCellWidth(getHeaderWidth(resizerToggleRef.current));
  }, []);
  (0, import_react5.useEffect)(() => {
    const elements = getResizerElements(resizerToggleRef.current);
    if (!isDragging && !resizerHasFocus || !elements) {
      return;
    }
    const { left: leftEdge, right: rightEdge } = elements.scrollParent.getBoundingClientRect();
    const updateTrackerPosition = (newOffset) => {
      const { left: scrollParentLeft } = elements.table.getBoundingClientRect();
      elements.tracker.style.top = elements.header.getBoundingClientRect().height + "px";
      elements.tracker.style.left = newOffset - scrollParentLeft - 1 + "px";
    };
    const updateColumnWidth = (newWidth) => {
      const { right, width } = elements.header.getBoundingClientRect();
      const updatedWidth = newWidth < minWidth ? minWidth : newWidth;
      updateTrackerPosition(right + updatedWidth - width);
      if (newWidth >= minWidth) {
        setHeaderCellWidth(newWidth);
      }
      onWidthUpdate(newWidth);
    };
    const resizeColumn = (offset) => {
      if (offset > leftEdge) {
        const cellLeft = elements.header.getBoundingClientRect().left;
        const newWidth = offset - cellLeft;
        updateColumnWidth(newWidth);
      }
    };
    const onAutoGrow = () => {
      const width = elements.header.getBoundingClientRect().width;
      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);
      updateColumnWidth(width + AUTO_GROW_INCREMENT);
      elements.scrollParent.scrollLeft += AUTO_GROW_INCREMENT;
    };
    const onMouseMove = (event) => {
      clearTimeout(autoGrowTimeout.current);
      const offset = event.pageX;
      if (offset > rightEdge) {
        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);
      } else {
        resizeColumn(offset);
      }
    };
    const onMouseUp = (event) => {
      resizeColumn(event.pageX);
      setIsDragging(false);
      onWidthUpdateCommit();
      clearTimeout(autoGrowTimeout.current);
    };
    const onKeyDown = (event) => {
      var _a, _b;
      if (isKeyboardDragging) {
        if (event.keyCode === KeyCode.left) {
          event.preventDefault();
          updateColumnWidth(elements.header.getBoundingClientRect().width - 10);
        }
        if (event.keyCode === KeyCode.right) {
          event.preventDefault();
          updateColumnWidth(elements.header.getBoundingClientRect().width + 10);
        }
        if (event.keyCode === KeyCode.enter || event.keyCode === KeyCode.space || event.keyCode === KeyCode.escape) {
          event.preventDefault();
          setIsKeyboardDragging(false);
          (_a = resizerToggleRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
      } else if (event.keyCode === KeyCode.enter || event.keyCode === KeyCode.space) {
        event.preventDefault();
        setIsKeyboardDragging(true);
        (_b = resizerSeparatorRef.current) === null || _b === void 0 ? void 0 : _b.focus();
      }
    };
    updateTrackerPosition(elements.header.getBoundingClientRect().right);
    if (isDragging) {
      document.body.classList.add(styles_css_default5["resize-active"]);
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
    if (resizerHasFocus) {
      document.body.classList.add(styles_css_default5["resize-active-with-focus"]);
      elements.header.addEventListener("keydown", onKeyDown);
    }
    if (isKeyboardDragging) {
      document.body.classList.add(styles_css_default5["resize-active"]);
    }
    return () => {
      clearTimeout(autoGrowTimeout.current);
      document.body.classList.remove(styles_css_default5["resize-active"]);
      document.body.classList.remove(styles_css_default5["resize-active-with-focus"]);
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      elements.header.removeEventListener("keydown", onKeyDown);
    };
  }, [minWidth, isDragging, isKeyboardDragging, resizerHasFocus, onWidthUpdate, onWidthUpdateCommit]);
  const { tabIndex: resizerTabIndex } = useSingleTabStopNavigation(resizerToggleRef, { tabIndex });
  return import_react5.default.createElement(
    import_react5.default.Fragment,
    null,
    import_react5.default.createElement("button", { ref: resizerToggleRef, className: clsx_m_default(styles_css_default5.resizer, (resizerHasFocus || showFocusRing || isKeyboardDragging) && styles_css_default5["has-focus"]), onMouseDown: (event) => {
      if (event.button !== 0) {
        return;
      }
      event.preventDefault();
      setIsDragging(true);
    }, onClick: () => {
      var _a;
      setIsDragging(false);
      setResizerHasFocus(true);
      setIsKeyboardDragging(true);
      (_a = resizerSeparatorRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, onFocus: () => {
      setHeaderCellWidth(getHeaderWidth(resizerToggleRef.current));
      setResizerHasFocus(true);
    }, onBlur: (event) => {
      if (event.relatedTarget !== resizerSeparatorRef.current) {
        setResizerHasFocus(false);
      }
    }, "aria-roledescription": roleDescription, "aria-labelledby": ariaLabelledby, tabIndex: resizerTabIndex, "data-focus-id": focusId }),
    import_react5.default.createElement("span", { className: clsx_m_default(styles_css_default5.divider, isDragging && styles_css_default5["divider-active"]), "data-awsui-table-suppress-navigation": true, ref: resizerSeparatorRef, id: separatorId, role: "separator", tabIndex: -1, "aria-hidden": !isKeyboardDragging, "aria-orientation": "vertical", "aria-valuenow": headerCellWidth, "aria-valuetext": headerCellWidth.toFixed(0), "aria-valuemin": minWidth, "data-focus-id": focusId, onBlur: () => {
      setResizerHasFocus(false);
      if (isKeyboardDragging) {
        setIsKeyboardDragging(false);
      }
      onWidthUpdateCommit();
    } })
  );
}
function ResizeTracker() {
  return import_react5.default.createElement("span", { className: styles_css_default5.tracker });
}

// node_modules/@cloudscape-design/components/table/header-cell/th-element.js
var import_react10 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-columns/use-sticky-columns.js
var import_react7 = __toESM(require_react());

// node_modules/@cloudscape-design/components/area-chart/async-store/index.js
var import_react6 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var AsyncStore = class {
  constructor(state) {
    this._listeners = [];
    this._state = state;
  }
  get() {
    return this._state;
  }
  set(cb) {
    const prevState = this._state;
    const newState = cb(prevState);
    this._state = newState;
    (0, import_react_dom.unstable_batchedUpdates)(() => {
      for (const [selector, listener] of this._listeners) {
        if (selector(prevState) !== selector(newState)) {
          listener(newState, prevState);
        }
      }
    });
  }
  subscribe(selector, listener) {
    this._listeners.push([selector, listener]);
    return () => this.unsubscribe(listener);
  }
  unsubscribe(listener) {
    for (let index = 0; index < this._listeners.length; index++) {
      const [, storedListener] = this._listeners[index];
      if (storedListener === listener) {
        this._listeners.splice(index, 1);
        break;
      }
    }
  }
};
function useReaction(store, selector, effect) {
  (0, import_react6.useLayoutEffect)(
    () => {
      const unsubscribe = store.subscribe(selector, (newState, prevState) => effect(selector(newState), selector(prevState)));
      return unsubscribe;
    },
    // ignoring selector and effect as they are expected to stay constant
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [store]
  );
}
function useSelector(store, selector) {
  const [state, setState] = (0, import_react6.useState)(selector(store.get()));
  useReaction(store, selector, (newState) => {
    setState(newState);
  });
  const prevStore = usePrevious(store);
  if (prevStore !== null && prevStore !== store) {
    return selector(store.get());
  }
  return state;
}

// node_modules/@cloudscape-design/components/table/sticky-columns/utils.js
function isCellStatesEqual(s1, s2) {
  if (s1 && s2) {
    return s1.padLeft === s2.padLeft && s1.lastLeft === s2.lastLeft && s1.lastRight === s2.lastRight && s1.offset.left === s2.offset.left && s1.offset.right === s2.offset.right;
  }
  return s1 === s2;
}
function isWrapperStatesEqual(s1, s2) {
  return s1.scrollPaddingLeft === s2.scrollPaddingLeft && s1.scrollPaddingRight === s2.scrollPaddingRight;
}
function updateCellOffsets(cells, props) {
  var _a, _b, _c, _d, _e, _f;
  const totalColumns = props.visibleColumns.length;
  const firstColumnsWidths = [];
  for (let i = 0; i < Math.min(totalColumns, props.stickyColumnsFirst); i++) {
    const element = cells.get(props.visibleColumns[i]);
    const cellWidth = (_a = element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : 0;
    firstColumnsWidths[i] = ((_b = firstColumnsWidths[i - 1]) !== null && _b !== void 0 ? _b : 0) + cellWidth;
  }
  const lastColumnsWidths = [];
  for (let i = 0; i < Math.min(totalColumns, props.stickyColumnsLast); i++) {
    const element = cells.get(props.visibleColumns[totalColumns - 1 - i]);
    const cellWidth = (_c = element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width) !== null && _c !== void 0 ? _c : 0;
    lastColumnsWidths[i] = ((_d = lastColumnsWidths[i - 1]) !== null && _d !== void 0 ? _d : 0) + cellWidth;
  }
  const stickyWidthLeft = (_e = firstColumnsWidths[props.stickyColumnsFirst - 1]) !== null && _e !== void 0 ? _e : 0;
  const stickyWidthRight = (_f = lastColumnsWidths[props.stickyColumnsLast - 1]) !== null && _f !== void 0 ? _f : 0;
  const offsets = props.visibleColumns.reduce((map, columnId, columnIndex) => {
    var _a2, _b2;
    return map.set(columnId, {
      first: (_a2 = firstColumnsWidths[columnIndex - 1]) !== null && _a2 !== void 0 ? _a2 : 0,
      last: (_b2 = lastColumnsWidths[totalColumns - 1 - columnIndex - 1]) !== null && _b2 !== void 0 ? _b2 : 0
    });
  }, /* @__PURE__ */ new Map());
  return { offsets, stickyWidthLeft, stickyWidthRight };
}

// node_modules/@cloudscape-design/components/table/sticky-columns/use-sticky-columns.js
var MINIMUM_SCROLLABLE_SPACE = 148;
function useStickyColumns({ visibleColumns, stickyColumnsFirst, stickyColumnsLast }) {
  const store = (0, import_react7.useMemo)(() => new StickyColumnsStore(), []);
  const wrapperRef = (0, import_react7.useRef)(null);
  const tableRef = (0, import_react7.useRef)(null);
  const cellsRef = (0, import_react7.useRef)(/* @__PURE__ */ new Map());
  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;
  const updateStickyStyles = useStableCallback(() => {
    if (wrapperRef.current && tableRef.current) {
      store.updateCellStyles({
        wrapper: wrapperRef.current,
        table: tableRef.current,
        cells: cellsRef.current,
        visibleColumns,
        stickyColumnsFirst,
        stickyColumnsLast
      });
    }
  });
  useResizeObserver(wrapperRef, updateStickyStyles);
  useResizeObserver(tableRef, updateStickyStyles);
  (0, import_react7.useEffect)(() => {
    if (wrapperRef.current && tableRef.current) {
      store.updateCellStyles({
        wrapper: wrapperRef.current,
        table: tableRef.current,
        cells: cellsRef.current,
        visibleColumns,
        stickyColumnsFirst,
        stickyColumnsLast
      });
    }
  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);
  (0, import_react7.useEffect)(() => {
    if (!hasStickyColumns) {
      return;
    }
    const selector = (state) => state.wrapperState;
    const updateWrapperStyles = (state, prev) => {
      if (isWrapperStatesEqual(state, prev)) {
        return;
      }
      if (wrapperRef.current) {
        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + "px";
        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + "px";
      }
    };
    const unsubscribe = store.subscribe(selector, (newState, prevState) => updateWrapperStyles(selector(newState), selector(prevState)));
    return unsubscribe;
  }, [store, hasStickyColumns]);
  const setWrapper = (0, import_react7.useCallback)((node) => {
    if (wrapperRef.current) {
      wrapperRef.current.removeEventListener("scroll", updateStickyStyles);
    }
    if (node && hasStickyColumns) {
      node.addEventListener("scroll", updateStickyStyles);
    }
    wrapperRef.current = node;
  }, [hasStickyColumns, updateStickyStyles]);
  const setTable = (0, import_react7.useCallback)((node) => {
    tableRef.current = node;
  }, []);
  const setCell = (0, import_react7.useCallback)((columnId, node) => {
    if (node) {
      cellsRef.current.set(columnId, node);
    } else {
      cellsRef.current.delete(columnId);
    }
  }, []);
  return {
    store,
    style: {
      // Provide wrapper styles as props so that a re-render won't cause invalidation.
      wrapper: hasStickyColumns ? Object.assign({}, store.get().wrapperState) : void 0
    },
    refs: { wrapper: setWrapper, table: setTable, cell: setCell }
  };
}
function useStickyCellStyles({ stickyColumns, columnId, getClassName }) {
  var _a;
  const setCell = stickyColumns.refs.cell;
  const unsubscribeRef = (0, import_react7.useRef)(null);
  const refCallback = (0, import_react7.useCallback)(
    (cellElement) => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
      }
      setCell(columnId, cellElement);
      const selector = (state) => {
        var _a2;
        return (_a2 = state.cellState.get(columnId)) !== null && _a2 !== void 0 ? _a2 : null;
      };
      const updateCellStyles = (state, prev) => {
        if (isCellStatesEqual(state, prev)) {
          return;
        }
        const className = getClassName(state);
        if (cellElement) {
          Object.keys(className).forEach((key) => {
            if (className[key]) {
              cellElement.classList.add(key);
            } else {
              cellElement.classList.remove(key);
            }
          });
          cellElement.style.left = (state === null || state === void 0 ? void 0 : state.offset.left) !== void 0 ? `${state.offset.left}px` : "";
          cellElement.style.right = (state === null || state === void 0 ? void 0 : state.offset.right) !== void 0 ? `${state.offset.right}px` : "";
        }
      };
      if (cellElement) {
        unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {
          updateCellStyles(selector(newState), selector(prevState));
        });
      }
    },
    // getClassName is expected to be pure
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [columnId, setCell, stickyColumns.store]
  );
  const cellStyles = stickyColumns.store.get().cellState.get(columnId);
  return {
    ref: refCallback,
    className: cellStyles ? clsx_m_default(getClassName(cellStyles)) : void 0,
    style: (_a = cellStyles === null || cellStyles === void 0 ? void 0 : cellStyles.offset) !== null && _a !== void 0 ? _a : void 0
  };
}
var StickyColumnsStore = class extends AsyncStore {
  constructor() {
    super({ cellState: /* @__PURE__ */ new Map(), wrapperState: { scrollPaddingLeft: 0, scrollPaddingRight: 0 } });
    this.cellOffsets = {
      offsets: /* @__PURE__ */ new Map(),
      stickyWidthLeft: 0,
      stickyWidthRight: 0
    };
    this.isStuckToTheLeft = false;
    this.isStuckToTheRight = false;
    this.padLeft = false;
    this.generateCellStyles = (props) => {
      const isEnabled = this.isEnabled(props);
      const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;
      const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;
      return props.visibleColumns.reduce((acc, columnId, index) => {
        var _a, _b, _c, _d;
        let stickySide = "non-sticky";
        if (index < props.stickyColumnsFirst) {
          stickySide = "left";
        } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {
          stickySide = "right";
        }
        if (!isEnabled || stickySide === "non-sticky") {
          return acc;
        }
        const isFirstColumn = index === 0;
        const stickyColumnOffsetLeft = (_b = (_a = this.cellOffsets.offsets.get(columnId)) === null || _a === void 0 ? void 0 : _a.first) !== null && _b !== void 0 ? _b : 0;
        const stickyColumnOffsetRight = (_d = (_c = this.cellOffsets.offsets.get(columnId)) === null || _c === void 0 ? void 0 : _c.last) !== null && _d !== void 0 ? _d : 0;
        acc.set(columnId, {
          padLeft: isFirstColumn && this.padLeft,
          lastLeft: this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,
          lastRight: this.isStuckToTheRight && lastRightStickyColumnIndex === index,
          offset: {
            left: stickySide === "left" ? stickyColumnOffsetLeft : void 0,
            right: stickySide === "right" ? stickyColumnOffsetRight : void 0
          }
        });
        return acc;
      }, /* @__PURE__ */ new Map());
    };
    this.updateCellOffsets = (props) => {
      this.cellOffsets = updateCellOffsets(props.cells, props);
    };
    this.isEnabled = (props) => {
      const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;
      if (noStickyColumns) {
        return false;
      }
      const wrapperWidth = props.wrapper.getBoundingClientRect().width;
      const tableWidth = props.table.getBoundingClientRect().width;
      const isWrapperScrollable = tableWidth > wrapperWidth;
      if (!isWrapperScrollable) {
        return false;
      }
      const totalStickySpace = this.cellOffsets.stickyWidthLeft + this.cellOffsets.stickyWidthRight;
      const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;
      const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;
      const hasEnoughScrollableSpace = totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;
      if (!hasEnoughScrollableSpace) {
        return false;
      }
      return true;
    };
  }
  updateCellStyles(props) {
    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;
    const hadStickyColumns = this.cellOffsets.offsets.size > 0;
    if (hasStickyColumns || hadStickyColumns) {
      this.updateScroll(props);
      this.updateCellOffsets(props);
      this.set(() => ({
        cellState: this.generateCellStyles(props),
        wrapperState: {
          scrollPaddingLeft: this.cellOffsets.stickyWidthLeft,
          scrollPaddingRight: this.cellOffsets.stickyWidthRight
        }
      }));
    }
  }
  updateScroll(props) {
    const wrapperScrollLeft = props.wrapper.scrollLeft;
    const wrapperScrollWidth = props.wrapper.scrollWidth;
    const wrapperClientWidth = props.wrapper.clientWidth;
    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;
    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;
    this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;
    this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;
    this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;
  }
};

// node_modules/@cloudscape-design/components/table/table-role/table-role-helper.js
var stateToAriaSort = {
  sortable: "none",
  ascending: "ascending",
  descending: "descending"
};
var getAriaSort = (sortingState) => stateToAriaSort[sortingState];
function getTableRoleProps(options) {
  const nativeProps = {};
  nativeProps.role = options.tableRole === "grid-default" ? "grid" : options.tableRole;
  nativeProps["aria-label"] = options.ariaLabel;
  nativeProps["aria-labelledby"] = options.ariaLabelledBy;
  nativeProps["aria-rowcount"] = options.totalItemsCount ? options.totalItemsCount + 1 : -1;
  if (options.tableRole === "grid") {
    nativeProps["aria-colcount"] = options.totalColumnsCount;
  }
  if (options.tableRole === "grid") {
    nativeProps.tabIndex = -1;
  }
  return nativeProps;
}
function getTableWrapperRoleProps(options) {
  const nativeProps = {};
  if (options.isScrollable) {
    nativeProps.role = "region";
    nativeProps.tabIndex = 0;
    nativeProps["aria-label"] = options.ariaLabel;
  }
  return nativeProps;
}
function getTableHeaderRowRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid" || options.tableRole === "grid-default") {
    nativeProps["aria-rowindex"] = 1;
  }
  return nativeProps;
}
function getTableRowRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid") {
    nativeProps["aria-rowindex"] = (options.firstIndex || 1) + options.rowIndex + 1;
  } else if (options.firstIndex !== void 0) {
    nativeProps["aria-rowindex"] = options.firstIndex + options.rowIndex + 1;
  }
  return nativeProps;
}
function getTableColHeaderRoleProps(options) {
  const nativeProps = {};
  nativeProps.scope = "col";
  if (options.tableRole === "grid") {
    nativeProps["aria-colindex"] = options.colIndex + 1;
  }
  if (options.sortingStatus) {
    nativeProps["aria-sort"] = getAriaSort(options.sortingStatus);
  }
  return nativeProps;
}
function getTableCellRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid") {
    nativeProps["aria-colindex"] = options.colIndex + 1;
  }
  if (options.isRowHeader) {
    nativeProps.scope = "row";
  }
  return nativeProps;
}

// node_modules/@cloudscape-design/components/table/table-role/grid-navigation.js
var import_react8 = __toESM(require_react());
var import_react9 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/table-role/utils.js
function getClosestCell(element) {
  return element.closest("td,th");
}
function isElementDisabled(element) {
  if (element instanceof HTMLInputElement || element instanceof HTMLButtonElement) {
    return element.disabled;
  }
  return false;
}
function defaultIsSuppressed(target) {
  let current = target;
  while (current) {
    if (current instanceof HTMLTableCellElement) {
      return false;
    }
    if (current.getAttribute("role") === "dialog" || current.getAttribute("data-awsui-table-suppress-navigation") === "true") {
      return true;
    }
    current = current.parentElement;
  }
  return false;
}
function findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta) {
  var _a;
  let targetRow = null;
  const rowElements = Array.from(table.querySelectorAll("tr[aria-rowindex]"));
  if (delta < 0) {
    rowElements.reverse();
  }
  for (const element of rowElements) {
    const rowIndex = parseInt((_a = element.getAttribute("aria-rowindex")) !== null && _a !== void 0 ? _a : "");
    targetRow = element;
    if (rowIndex === targetAriaRowIndex) {
      break;
    }
    if (delta >= 0 && rowIndex > targetAriaRowIndex) {
      break;
    }
    if (delta < 0 && rowIndex < targetAriaRowIndex) {
      break;
    }
  }
  return targetRow;
}
function findTableRowCellByAriaColIndex(tableRow, targetAriaColIndex, delta) {
  var _a;
  let targetCell = null;
  const cellElements = Array.from(tableRow.querySelectorAll("td[aria-colindex],th[aria-colindex]"));
  if (delta < 0) {
    cellElements.reverse();
  }
  for (const element of cellElements) {
    const columnIndex = parseInt((_a = element.getAttribute("aria-colindex")) !== null && _a !== void 0 ? _a : "");
    targetCell = element;
    if (columnIndex === targetAriaColIndex) {
      break;
    }
    if (delta >= 0 && columnIndex > targetAriaColIndex) {
      break;
    }
    if (delta < 0 && columnIndex < targetAriaColIndex) {
      break;
    }
  }
  return targetCell;
}

// node_modules/@cloudscape-design/components/table/table-role/grid-navigation.js
function GridNavigationProvider({ keyboardNavigation, pageSize, getTable, children }) {
  const gridNavigation = (0, import_react9.useMemo)(() => new GridNavigationProcessor(), []);
  const getTableStable = useStableCallback(getTable);
  (0, import_react9.useEffect)(() => {
    if (keyboardNavigation) {
      const table = getTableStable();
      table && gridNavigation.init(table);
    }
    return () => gridNavigation.cleanup();
  }, [keyboardNavigation, gridNavigation, getTableStable]);
  (0, import_react9.useEffect)(() => {
    gridNavigation.update({ pageSize });
  }, [gridNavigation, pageSize]);
  (0, import_react9.useEffect)(() => {
    if (keyboardNavigation) {
      gridNavigation.refresh();
    }
  });
  return import_react8.default.createElement(SingleTabStopNavigationContext.Provider, { value: {
    navigationActive: keyboardNavigation,
    registerFocusable: gridNavigation.registerFocusable
  } }, children);
}
var GridNavigationProcessor = class {
  constructor() {
    this._pageSize = 0;
    this._table = null;
    this.focusedCell = null;
    this.keepUserIndex = false;
    this.focusables = /* @__PURE__ */ new Set();
    this.focusHandlers = /* @__PURE__ */ new Map();
    this.focusablesState = /* @__PURE__ */ new WeakMap();
    this.focusTarget = null;
    this.registerFocusable = (focusableElement, changeHandler) => {
      var _a;
      this.focusables.add(focusableElement);
      this.focusHandlers.set(focusableElement, changeHandler);
      const isFocusable = (_a = this.focusablesState.get(focusableElement)) !== null && _a !== void 0 ? _a : false;
      const newIsFocusable = this.focusTarget === focusableElement || this.isSuppressed(focusableElement);
      if (newIsFocusable !== isFocusable) {
        this.focusablesState.set(focusableElement, newIsFocusable);
        changeHandler(newIsFocusable);
      }
      return () => this.unregisterFocusable(focusableElement);
    };
    this.unregisterFocusable = (focusable) => {
      this.focusables.delete(focusable);
      this.focusHandlers.delete(focusable);
    };
    this.onFocusin = (event) => {
      if (!(event.target instanceof HTMLElement)) {
        return;
      }
      this.updateFocusedCell(event.target);
      if (!this.focusedCell) {
        return;
      }
      this.updateFocusTarget();
      const cellElement = getClosestCell(this.focusedCell.element);
      const nextTarget = this.focusedCell.element === cellElement ? this.getFocusablesFrom(cellElement)[0] : null;
      if (nextTarget) {
        nextTarget.focus();
      } else {
        this.keepUserIndex = false;
      }
    };
    this.onFocusout = () => {
      setTimeout(() => {
        if (this.focusedCell && !nodeBelongs(this.table, this.focusedCell.element)) {
          this.moveFocusBy(this.focusedCell, { x: 0, y: 0 });
        }
      }, 0);
    };
    this.onKeydown = (event) => {
      if (!this.focusedCell) {
        return;
      }
      const ctrlKey = event.ctrlKey ? 1 : 0;
      const altKey = event.altKey ? 1 : 0;
      const shiftKey = event.shiftKey ? 1 : 0;
      const metaKey = event.metaKey ? 1 : 0;
      const numModifiersPressed = ctrlKey + altKey + shiftKey + metaKey;
      let key = event.keyCode;
      if (numModifiersPressed === 1 && event.ctrlKey) {
        key = -key;
      } else if (numModifiersPressed) {
        return;
      }
      const from = this.focusedCell;
      if (this.isSuppressed(document.activeElement) || !this.isRegistered(document.activeElement)) {
        return;
      }
      switch (key) {
        case KeyCode.up:
          event.preventDefault();
          return this.moveFocusBy(from, { y: -1, x: 0 });
        case KeyCode.down:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 1, x: 0 });
        case KeyCode.left:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 0, x: -1 });
        case KeyCode.right:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 0, x: 1 });
        case KeyCode.pageUp:
          event.preventDefault();
          return this.moveFocusBy(from, { y: -this.pageSize, x: 0 });
        case KeyCode.pageDown:
          event.preventDefault();
          return this.moveFocusBy(from, { y: this.pageSize, x: 0 });
        case KeyCode.home:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 0, x: -Infinity });
        case KeyCode.end:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 0, x: Infinity });
        case -KeyCode.home:
          event.preventDefault();
          return this.moveFocusBy(from, { y: -Infinity, x: -Infinity });
        case -KeyCode.end:
          event.preventDefault();
          return this.moveFocusBy(from, { y: Infinity, x: Infinity });
        default:
          return;
      }
    };
  }
  init(table) {
    this._table = table;
    this.table.addEventListener("focusin", this.onFocusin);
    this.table.addEventListener("focusout", this.onFocusout);
    this.table.addEventListener("keydown", this.onKeydown);
    this.updateFocusTarget();
    this.cleanup = () => {
      this.table.removeEventListener("focusin", this.onFocusin);
      this.table.removeEventListener("focusout", this.onFocusout);
      this.table.removeEventListener("keydown", this.onKeydown);
      this.focusables.forEach(this.unregisterFocusable);
    };
  }
  cleanup() {
  }
  update({ pageSize }) {
    this._pageSize = pageSize;
  }
  refresh() {
    setTimeout(() => {
      var _a;
      if (this._table) {
        this.updateFocusedCell((_a = this.focusedCell) === null || _a === void 0 ? void 0 : _a.element);
        this.updateFocusTarget();
      }
    }, 0);
  }
  get pageSize() {
    return this._pageSize;
  }
  get table() {
    if (!this._table) {
      throw new Error("Invariant violation: GridNavigationProcessor is used before initialization.");
    }
    return this._table;
  }
  moveFocusBy(cell, delta) {
    var _a;
    if (delta.y !== 0 && delta.x === 0) {
      this.keepUserIndex = true;
    }
    (_a = this.getNextFocusable(cell, delta)) === null || _a === void 0 ? void 0 : _a.focus();
  }
  updateFocusTarget() {
    var _a;
    this.focusTarget = this.getSingleFocusable();
    for (const focusableElement of this.focusables) {
      const isFocusable = (_a = this.focusablesState.get(focusableElement)) !== null && _a !== void 0 ? _a : false;
      const newIsFocusable = this.focusTarget === focusableElement || this.isSuppressed(focusableElement);
      if (newIsFocusable !== isFocusable) {
        this.focusablesState.set(focusableElement, newIsFocusable);
        this.focusHandlers.get(focusableElement)(newIsFocusable);
      }
    }
  }
  isSuppressed(element) {
    if (!this.focusedCell) {
      return false;
    }
    return !element || defaultIsSuppressed(element);
  }
  isRegistered(element) {
    return !element || this.focusables.has(element);
  }
  updateFocusedCell(focusedElement) {
    var _a, _b, _c, _d, _e, _f;
    if (!focusedElement) {
      return;
    }
    const cellElement = getClosestCell(focusedElement);
    const rowElement = cellElement === null || cellElement === void 0 ? void 0 : cellElement.closest("tr");
    if (!cellElement || !rowElement) {
      return;
    }
    const colIndex = parseInt((_a = cellElement.getAttribute("aria-colindex")) !== null && _a !== void 0 ? _a : "");
    const rowIndex = parseInt((_b = rowElement.getAttribute("aria-rowindex")) !== null && _b !== void 0 ? _b : "");
    if (isNaN(colIndex) || isNaN(rowIndex)) {
      return;
    }
    const cellFocusables = this.getFocusablesFrom(cellElement);
    const elementIndex = cellFocusables.indexOf(focusedElement);
    const prevColIndex = (_d = (_c = this.focusedCell) === null || _c === void 0 ? void 0 : _c.colIndex) !== null && _d !== void 0 ? _d : -1;
    const prevElementIndex = (_f = (_e = this.focusedCell) === null || _e === void 0 ? void 0 : _e.elementIndex) !== null && _f !== void 0 ? _f : -1;
    this.focusedCell = {
      rowIndex,
      colIndex: this.keepUserIndex && prevColIndex !== -1 ? prevColIndex : colIndex,
      elementIndex: this.keepUserIndex && prevElementIndex !== -1 ? prevElementIndex : elementIndex,
      element: focusedElement
    };
  }
  getNextFocusable(from, delta) {
    var _a;
    const targetAriaRowIndex = from.rowIndex + delta.y;
    const targetRow = findTableRowByAriaRowIndex(this.table, targetAriaRowIndex, delta.y);
    if (!targetRow) {
      return null;
    }
    const cellElement = getClosestCell(from.element);
    const cellFocusables = cellElement ? this.getFocusablesFrom(cellElement) : [];
    const nextElementIndex = from.elementIndex + delta.x;
    if (delta.x && from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length) {
      return cellFocusables[nextElementIndex];
    }
    const targetAriaColIndex = from.colIndex + delta.x;
    const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);
    if (!targetCell) {
      return null;
    }
    if (targetCell === cellElement && delta.x !== 0) {
      return null;
    }
    const targetCellFocusables = this.getFocusablesFrom(targetCell);
    let focusIndex = from.elementIndex;
    if (isFinite(delta.x) && delta.x > 0 || delta.x === -Infinity) {
      focusIndex = 0;
    }
    if (isFinite(delta.x) && delta.x < 0 || delta.x === Infinity) {
      focusIndex = targetCellFocusables.length - 1;
    }
    return (_a = targetCellFocusables[focusIndex]) !== null && _a !== void 0 ? _a : targetCell;
  }
  getSingleFocusable() {
    var _a;
    const cell = this.focusedCell;
    const firstTableCell = this.table.querySelector("td,th");
    let focusTarget = (_a = firstTableCell && this.getFocusablesFrom(firstTableCell)[0]) !== null && _a !== void 0 ? _a : firstTableCell;
    if (cell) {
      focusTarget = this.getNextFocusable(cell, { x: 0, y: 0 });
    }
    return focusTarget;
  }
  getFocusablesFrom(target) {
    return getAllFocusables(target).filter((el) => this.focusables.has(el) && !isElementDisabled(el));
  }
};

// node_modules/@cloudscape-design/components/table/header-cell/th-element.js
function TableThElement({ className, style, sortingStatus, sortingDisabled, focusedComponent, hidden, colIndex, columnId, stickyState, cellRef, tableRole, children }) {
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId,
    getClassName: (props) => getStickyClassNames(styles_css_default4, props)
  });
  const cellRefObject = (0, import_react10.useRef)(null);
  const mergedRef = useMergeRefs(stickyStyles.ref, cellRef, cellRefObject);
  const { tabIndex: cellTabIndex } = useSingleTabStopNavigation(cellRefObject);
  return import_react10.default.createElement("th", Object.assign({ "data-focus-id": `header-${String(columnId)}`, className: clsx_m_default(className, {
    [styles_css_default4["header-cell-fake-focus"]]: focusedComponent === `header-${String(columnId)}`,
    [styles_css_default4["header-cell-sortable"]]: sortingStatus,
    [styles_css_default4["header-cell-sorted"]]: sortingStatus === "ascending" || sortingStatus === "descending",
    [styles_css_default4["header-cell-disabled"]]: sortingDisabled,
    [styles_css_default4["header-cell-ascending"]]: sortingStatus === "ascending",
    [styles_css_default4["header-cell-descending"]]: sortingStatus === "descending",
    [styles_css_default4["header-cell-hidden"]]: hidden
  }, stickyStyles.className), style: Object.assign(Object.assign({}, style), stickyStyles.style), ref: mergedRef }, getTableColHeaderRoleProps({ tableRole, sortingStatus, colIndex }), { tabIndex: cellTabIndex }), children);
}

// node_modules/@cloudscape-design/components/table/header-cell/index.js
function TableHeaderCell({ className, style, tabIndex, column, activeSortingColumn, sortingDescending, sortingDisabled, wrapLines, focusedComponent, hidden, onClick, colIndex, updateColumn, resizableColumns, onResizeFinish, isEditable, columnId, stickyState, cellRef, tableRole, resizerRoleDescription }) {
  var _a;
  const i18n = useInternalI18n("table");
  const sortable = !!column.sortingComparator || !!column.sortingField;
  const sorted = !!activeSortingColumn && isSorted(column, activeSortingColumn);
  const sortingStatus = getSortingStatus(sortable, sorted, !!sortingDescending, !!sortingDisabled);
  const handleClick = () => onClick({
    sortingColumn: column,
    isDescending: sorted ? !sortingDescending : false
  });
  const handleKeyPress = ({ nativeEvent: e }) => {
    if (e.keyCode === KeyCode.enter || e.keyCode === KeyCode.space) {
      e.preventDefault();
      handleClick();
    }
  };
  const headerId = useUniqueId("table-header-");
  const clickableHeaderRef = (0, import_react11.useRef)(null);
  const { tabIndex: clickableHeaderTabIndex } = useSingleTabStopNavigation(clickableHeaderRef, { tabIndex });
  return import_react11.default.createElement(
    TableThElement,
    { className, style, cellRef, sortingStatus, sortingDisabled, focusedComponent, hidden, colIndex, columnId, stickyState, tableRole },
    import_react11.default.createElement(
      "div",
      Object.assign({ ref: clickableHeaderRef, "data-focus-id": `sorting-control-${String(columnId)}`, className: clsx_m_default(styles_css_default4["header-cell-content"], {
        [styles_css_default4["header-cell-fake-focus"]]: focusedComponent === `sorting-control-${String(columnId)}`
      }), "aria-label": column.ariaLabel ? column.ariaLabel({
        sorted,
        descending: sorted && !!sortingDescending,
        disabled: !!sortingDisabled
      }) : void 0 }, sortingStatus && !sortingDisabled ? {
        onKeyPress: handleKeyPress,
        tabIndex: clickableHeaderTabIndex,
        role: "button",
        onClick: handleClick
      } : {}),
      import_react11.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default4["header-cell-text"], wrapLines && styles_css_default4["header-cell-text-wrap"]), id: headerId },
        column.header,
        isEditable ? import_react11.default.createElement(
          "span",
          { className: styles_css_default4["edit-icon"], role: "img", "aria-label": i18n("columnDefinitions.editConfig.editIconAriaLabel", (_a = column.editConfig) === null || _a === void 0 ? void 0 : _a.editIconAriaLabel) },
          import_react11.default.createElement(internal_default, { name: "edit" })
        ) : null
      ),
      sortingStatus && import_react11.default.createElement(
        "span",
        { className: styles_css_default4["sorting-icon"] },
        import_react11.default.createElement(internal_default, { name: getSortingIconName(sortingStatus) })
      )
    ),
    resizableColumns ? import_react11.default.createElement(Resizer, { tabIndex, focusId: `resize-control-${String(columnId)}`, showFocusRing: focusedComponent === `resize-control-${String(columnId)}`, onWidthUpdate: (newWidth) => updateColumn(columnId, newWidth), onWidthUpdateCommit: onResizeFinish, ariaLabelledby: headerId, minWidth: typeof column.minWidth === "string" ? parseInt(column.minWidth) : column.minWidth, roleDescription: i18n("ariaLabels.resizerRoleDescription", resizerRoleDescription) }) : import_react11.default.createElement(Divider, { className: styles_css_default4["resize-divider"] })
  );
}

// node_modules/@cloudscape-design/components/table/thead.js
var Thead = import_react12.default.forwardRef(({ selectionType, getSelectAllProps, columnDefinitions, sortingColumn, sortingDisabled, sortingDescending, resizableColumns, variant, wrapLines, onFocusMove, onSortingChange, onResizeFinish, singleSelectionHeaderAriaLabel, stripedRows, sticky = false, hidden = false, stuck = false, stickyState, selectionColumnId: selectionColumnId2, focusedComponent, onFocusedComponentChange, tableRole, resizerRoleDescription }, outerRef) => {
  const isVisualRefresh = useVisualRefresh();
  const headerCellClass = clsx_m_default(styles_css_default4["header-cell"], styles_css_default4[`header-cell-variant-${variant}`], sticky && styles_css_default4["header-cell-sticky"], stuck && styles_css_default4["header-cell-stuck"], stripedRows && styles_css_default4["has-striped-rows"], isVisualRefresh && styles_css_default4["is-visual-refresh"]);
  const selectionCellClass = clsx_m_default(styles_css_default2["selection-control"], styles_css_default2["selection-control-header"], isVisualRefresh && styles_css_default2["is-visual-refresh"]);
  const { getColumnStyles, columnWidths, updateColumn, setCell } = useColumnWidths();
  return import_react12.default.createElement(
    "thead",
    { className: clsx_m_default(!hidden && styles_css_default2["thead-active"]) },
    import_react12.default.createElement(
      "tr",
      Object.assign({}, focusMarkers.all, { ref: outerRef, "aria-rowindex": 1 }, getTableHeaderRowRoleProps({ tableRole }), { onFocus: (event) => {
        var _a;
        const focusControlElement = findUpUntil(event.target, (element) => !!element.getAttribute("data-focus-id"));
        const focusId = (_a = focusControlElement === null || focusControlElement === void 0 ? void 0 : focusControlElement.getAttribute("data-focus-id")) !== null && _a !== void 0 ? _a : null;
        onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(focusId);
      }, onBlur: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(null) }),
      selectionType ? import_react12.default.createElement(
        TableThElement,
        { className: clsx_m_default(headerCellClass, selectionCellClass, hidden && styles_css_default4["header-cell-hidden"]), hidden, tableRole, colIndex: 0, focusedComponent, columnId: selectionColumnId2, stickyState },
        selectionType === "multi" ? import_react12.default.createElement(SelectionControl, Object.assign({ tableRole, onFocusDown: (event) => {
          onFocusMove(event.target, -1, 1);
        }, focusedComponent }, getSelectAllProps(), sticky ? { tabIndex: -1 } : {})) : import_react12.default.createElement(ScreenreaderOnly, null, singleSelectionHeaderAriaLabel),
        import_react12.default.createElement(Divider, { className: styles_css_default2["resize-divider"] })
      ) : null,
      columnDefinitions.map((column, colIndex) => {
        const columnId = getColumnKey(column, colIndex);
        return import_react12.default.createElement(TableHeaderCell, { key: columnId, style: getColumnStyles(sticky, columnId), className: headerCellClass, tabIndex: sticky ? -1 : 0, focusedComponent, column, activeSortingColumn: sortingColumn, sortingDescending, sortingDisabled, wrapLines, hidden, colIndex: selectionType ? colIndex + 1 : colIndex, columnId, updateColumn, onResizeFinish: () => onResizeFinish(columnWidths), resizableColumns, onClick: (detail) => fireNonCancelableEvent(onSortingChange, detail), isEditable: !!column.editConfig, stickyState, cellRef: (node) => setCell(sticky, columnId, node), tableRole, resizerRoleDescription });
      })
    )
  );
});
var thead_default = Thead;

// node_modules/@cloudscape-design/components/table/body-cell/styles.css.js
import "/home/bryanchasko/code/rgc3/node_modules/@cloudscape-design/components/table/body-cell/styles.scoped.css";
var styles_css_default6 = {
  "body-cell": "awsui_body-cell_c6tup_6muoq_99",
  "sticky-cell": "awsui_sticky-cell_c6tup_6muoq_133",
  "body-cell-wrap": "awsui_body-cell-wrap_c6tup_6muoq_136",
  "is-visual-refresh": "awsui_is-visual-refresh_c6tup_6muoq_148",
  "has-striped-rows": "awsui_has-striped-rows_c6tup_6muoq_160",
  "body-cell-edit-active": "awsui_body-cell-edit-active_c6tup_6muoq_163",
  "body-cell-editable": "awsui_body-cell-editable_c6tup_6muoq_163",
  "has-striped-rows-sticky-cell-pad-left": "awsui_has-striped-rows-sticky-cell-pad-left_c6tup_6muoq_169",
  "has-selection": "awsui_has-selection_c6tup_6muoq_172",
  "body-cell-first-row": "awsui_body-cell-first-row_c6tup_6muoq_178",
  "body-cell-last-row": "awsui_body-cell-last-row_c6tup_6muoq_181",
  "body-cell-selected": "awsui_body-cell-selected_c6tup_6muoq_181",
  "has-footer": "awsui_has-footer_c6tup_6muoq_181",
  "body-cell-shaded": "awsui_body-cell-shaded_c6tup_6muoq_191",
  "sticky-cell-pad-left": "awsui_sticky-cell-pad-left_c6tup_6muoq_225",
  "sticky-cell-last-right": "awsui_sticky-cell-last-right_c6tup_6muoq_242",
  "sticky-cell-last-left": "awsui_sticky-cell-last-left_c6tup_6muoq_246",
  "body-cell-next-selected": "awsui_body-cell-next-selected_c6tup_6muoq_269",
  "body-cell-prev-selected": "awsui_body-cell-prev-selected_c6tup_6muoq_273",
  "body-cell-editor-wrapper": "awsui_body-cell-editor-wrapper_c6tup_6muoq_297",
  "body-cell-success": "awsui_body-cell-success_c6tup_6muoq_304",
  "body-cell-editor": "awsui_body-cell-editor_c6tup_6muoq_297",
  "body-cell-editor-disabled": "awsui_body-cell-editor-disabled_c6tup_6muoq_331",
  "body-cell-editor-form": "awsui_body-cell-editor-form_c6tup_6muoq_340",
  "body-cell-editor-row": "awsui_body-cell-editor-row_c6tup_6muoq_350",
  "body-cell-editor-controls": "awsui_body-cell-editor-controls_c6tup_6muoq_360",
  "body-cell-interactive": "awsui_body-cell-interactive_c6tup_6muoq_381",
  "body-cell-edit-disabled-popover": "awsui_body-cell-edit-disabled-popover_c6tup_6muoq_423",
  "body-cell-has-success": "awsui_body-cell-has-success_c6tup_6muoq_427"
};

// node_modules/@cloudscape-design/components/table/body-cell/index.js
var import_react17 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/body-cell/td-element.js
var import_react13 = __toESM(require_react());
var TableTdElement = import_react13.default.forwardRef(({ className, style, children, wrapLines, isRowHeader, isFirstRow, isLastRow, isSelected, isNextSelected, isPrevSelected, nativeAttributes, onClick, onMouseEnter, onMouseLeave, isEvenRow, stripedRows, isVisualRefresh, hasSelection, hasFooter, columnId, colIndex, stickyState, tableRole }, ref) => {
  const Element = isRowHeader ? "th" : "td";
  nativeAttributes = Object.assign(Object.assign({}, nativeAttributes), getTableCellRoleProps({ tableRole, isRowHeader, colIndex }));
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId,
    getClassName: (props) => getStickyClassNames(styles_css_default6, props)
  });
  const cellRefObject = (0, import_react13.useRef)(null);
  const mergedRef = useMergeRefs(stickyStyles.ref, ref, cellRefObject);
  const { tabIndex: cellTabIndex } = useSingleTabStopNavigation(cellRefObject);
  return import_react13.default.createElement(Element, Object.assign({ style: Object.assign(Object.assign({}, style), stickyStyles.style), className: clsx_m_default(className, styles_css_default6["body-cell"], wrapLines && styles_css_default6["body-cell-wrap"], isFirstRow && styles_css_default6["body-cell-first-row"], isLastRow && styles_css_default6["body-cell-last-row"], isSelected && styles_css_default6["body-cell-selected"], isNextSelected && styles_css_default6["body-cell-next-selected"], isPrevSelected && styles_css_default6["body-cell-prev-selected"], !isEvenRow && stripedRows && styles_css_default6["body-cell-shaded"], stripedRows && styles_css_default6["has-striped-rows"], isVisualRefresh && styles_css_default6["is-visual-refresh"], hasSelection && styles_css_default6["has-selection"], hasFooter && styles_css_default6["has-footer"], stickyStyles.className), onClick, onMouseEnter, onMouseLeave, ref: mergedRef }, nativeAttributes, { tabIndex: cellTabIndex }), children);
});

// node_modules/@cloudscape-design/components/table/body-cell/inline-editor.js
var import_react15 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/body-cell/click-away.js
var import_react14 = __toESM(require_react());
function useClickAway(onClick) {
  const awayRef = (0, import_react14.useRef)(null);
  const onClickStable = useStableCallback(onClick);
  (0, import_react14.useEffect)(() => {
    function handleClick(event) {
      if (!nodeBelongs(awayRef.current, event.target)) {
        onClickStable();
      }
    }
    document.addEventListener("click", handleClick, { capture: true });
    return () => document.removeEventListener("click", handleClick, { capture: true });
  }, [onClickStable]);
  return awayRef;
}

// node_modules/@cloudscape-design/components/table/body-cell/inline-editor.js
var noop = () => void 0;
function InlineEditor({ ariaLabels, item, column, onEditEnd, submitEdit, __onRender }) {
  var _a, _b, _c, _d;
  const [currentEditLoading, setCurrentEditLoading] = (0, import_react15.useState)(false);
  const [currentEditValue, setCurrentEditValue] = (0, import_react15.useState)();
  const i18n = useInternalI18n("table");
  const focusLockRef = (0, import_react15.useRef)(null);
  const cellContext = {
    currentValue: currentEditValue,
    setValue: setCurrentEditValue
  };
  function finishEdit({ cancelled = false, refocusCell = true } = {}) {
    if (!cancelled) {
      setCurrentEditValue(void 0);
    }
    onEditEnd({ cancelled, refocusCell });
  }
  function onSubmitClick(evt) {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      evt.preventDefault();
      if (currentEditValue === void 0) {
        finishEdit();
        return;
      }
      setCurrentEditLoading(true);
      try {
        yield submitEdit(item, column, currentEditValue);
        setCurrentEditLoading(false);
        finishEdit();
      } catch (e) {
        setCurrentEditLoading(false);
        (_a2 = focusLockRef.current) === null || _a2 === void 0 ? void 0 : _a2.focusFirst();
      }
    });
  }
  function onCancel({ reFocusEditedCell = true } = {}) {
    if (currentEditLoading) {
      return;
    }
    finishEdit({ cancelled: true, refocusCell: reFocusEditedCell });
  }
  function handleEscape(event) {
    if (event.key === "Escape") {
      onCancel();
    }
  }
  const clickAwayRef = useClickAway(() => onCancel({ reFocusEditedCell: false }));
  (0, import_react15.useEffect)(() => {
    if (__onRender) {
      const timer = setTimeout(__onRender, 1);
      return () => clearTimeout(timer);
    }
  }, [__onRender]);
  const { ariaLabel = void 0, validation = noop, errorIconAriaLabel, constraintText, editingCell } = column.editConfig;
  return import_react15.default.createElement(
    focus_lock_default,
    { restoreFocus: true, ref: focusLockRef },
    import_react15.default.createElement(
      "div",
      { role: "dialog", ref: clickAwayRef, "aria-label": (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, column, item), onKeyDown: handleEscape },
      import_react15.default.createElement(
        "form",
        { onSubmit: onSubmitClick, className: styles_css_default6["body-cell-editor-form"] },
        import_react15.default.createElement(
          InternalFormField,
          { stretch: true, label: ariaLabel, constraintText, __hideLabel: true, __disableGutters: true, i18nStrings: { errorIconAriaLabel }, errorText: validation(item, currentEditValue) },
          import_react15.default.createElement(
            "div",
            { className: styles_css_default6["body-cell-editor-row"] },
            editingCell(item, cellContext),
            import_react15.default.createElement(
              "span",
              { className: styles_css_default6["body-cell-editor-controls"] },
              import_react15.default.createElement(
                InternalSpaceBetween,
                { direction: "horizontal", size: "xxs" },
                !currentEditLoading ? import_react15.default.createElement(internal_default2, { ariaLabel: (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.cancelEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column), formAction: "none", iconName: "close", variant: "inline-icon", onClick: () => onCancel() }) : null,
                import_react15.default.createElement(internal_default2, { ariaLabel: (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.submitEditLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, column), formAction: "submit", iconName: "check", variant: "inline-icon", loading: currentEditLoading })
              ),
              import_react15.default.createElement(live_region_default, null, currentEditLoading ? i18n("ariaLabels.submittingEditText", (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.submittingEditText) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, column)) : "")
            )
          )
        )
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/disabled-inline-editor.js
var import_react16 = __toESM(require_react());
function DisabledInlineEditor(_a) {
  var _b;
  var { className, item, column, ariaLabels, isEditing, onEditStart, onEditEnd, editDisabledReason, isVisualRefresh, interactiveCell = true } = _a, rest = __rest(_a, ["className", "item", "column", "ariaLabels", "isEditing", "onEditStart", "onEditEnd", "editDisabledReason", "isVisualRefresh", "interactiveCell"]);
  const clickAwayRef = useClickAway(() => {
    if (isEditing) {
      onEditEnd(true);
    }
  });
  const [hasHover, setHasHover] = (0, import_react16.useState)(false);
  const [hasFocus, setHasFocus] = (0, import_react16.useState)(false);
  const showIcon = hasHover || hasFocus || isEditing || !interactiveCell;
  const iconRef = (0, import_react16.useRef)(null);
  const buttonRef = (0, import_react16.useRef)(null);
  const portalRef = (0, import_react16.useRef)(null);
  function handleEscape(event) {
    if (event.key === "Escape") {
      onEditEnd(true);
    }
  }
  const onClick = () => {
    var _a2;
    onEditStart();
    (_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
  };
  const { targetProps, descriptionEl } = useHiddenDescription(editDisabledReason);
  const portalClasses = usePortalModeClasses(portalRef);
  const { tabIndex } = useSingleTabStopNavigation(buttonRef);
  return import_react16.default.createElement(
    TableTdElement,
    Object.assign({}, rest, { nativeAttributes: { "data-inline-editing-active": isEditing.toString() }, className: clsx_m_default(className, styles_css_default6["body-cell-editable"], interactiveCell && styles_css_default6["body-cell-interactive"], isEditing && styles_css_default6["body-cell-edit-disabled-popover"], isVisualRefresh && styles_css_default6["is-visual-refresh"]), onClick: interactiveCell && !isEditing ? onClick : void 0, onMouseEnter: () => setHasHover(true), onMouseLeave: () => setHasHover(false), ref: clickAwayRef }),
    column.cell(item),
    import_react16.default.createElement(
      "div",
      { className: styles_css_default6["body-cell-editor-wrapper"] },
      import_react16.default.createElement(
        "button",
        Object.assign({ ref: buttonRef, tabIndex, className: clsx_m_default(styles_css_default6["body-cell-editor"], styles_css_default6["body-cell-editor-disabled"]), "aria-label": (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column, item), "aria-haspopup": "dialog", "aria-disabled": "true", onClick: !interactiveCell && !isEditing ? onClick : void 0, onFocus: () => setHasFocus(true), onBlur: () => setHasFocus(false), onKeyDown: handleEscape }, targetProps),
        showIcon && import_react16.default.createElement(internal_default, { name: "lock-private", variant: "normal", __internalRootRef: iconRef }),
        descriptionEl
      )
    ),
    isEditing && import_react16.default.createElement(
      "span",
      { ref: portalRef },
      import_react16.default.createElement(
        Portal,
        null,
        import_react16.default.createElement(
          "span",
          { className: portalClasses },
          import_react16.default.createElement(
            PopoverContainer,
            { size: "medium", fixedWidth: false, position: "top", trackRef: iconRef, arrow: (position) => import_react16.default.createElement(arrow_default, { position }), renderWithPortal: true, zIndex: 2e3 },
            import_react16.default.createElement(
              PopoverBody,
              { dismissButton: false, dismissAriaLabel: void 0, header: null, onDismiss: () => {
              }, overflowVisible: "both" },
              import_react16.default.createElement("span", { "aria-live": "polite" }, editDisabledReason)
            )
          )
        )
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/index.js
var submitHandlerFallback = () => {
  throw new Error("The function `handleSubmit` is required for editable columns");
};
function TableCellEditable(_a) {
  var _b, _c, _d;
  var { className, item, column, isEditing, onEditStart, onEditEnd, submitEdit, ariaLabels, isVisualRefresh, successfulEdit = false, interactiveCell = true } = _a, rest = __rest(_a, ["className", "item", "column", "isEditing", "onEditStart", "onEditEnd", "submitEdit", "ariaLabels", "isVisualRefresh", "successfulEdit", "interactiveCell"]);
  const i18n = useInternalI18n("table");
  const editActivateRef = (0, import_react17.useRef)(null);
  const tdNativeAttributes = {
    "data-inline-editing-active": isEditing.toString()
  };
  const isFocusMoveNeededRef = (0, import_react17.useRef)(false);
  (0, import_react17.useEffect)(() => {
    if (!isEditing && editActivateRef.current && isFocusMoveNeededRef.current) {
      isFocusMoveNeededRef.current = false;
      editActivateRef.current.focus();
    }
  }, [isEditing]);
  const [hasHover, setHasHover] = (0, import_react17.useState)(false);
  const [hasFocus, setHasFocus] = (0, import_react17.useState)(false);
  const showIcon = hasHover || hasFocus || !interactiveCell;
  const prevSuccessfulEdit = usePrevious(successfulEdit);
  const prevHasFocus = usePrevious(hasFocus);
  const [showSuccessIcon, setShowSuccessIcon] = (0, import_react17.useState)(false);
  (0, import_react17.useEffect)(() => {
    if (successfulEdit && prevSuccessfulEdit && !hasFocus && prevHasFocus) {
      setShowSuccessIcon(false);
    }
    if (successfulEdit && !prevSuccessfulEdit) {
      setShowSuccessIcon(true);
    }
  }, [hasFocus, successfulEdit, prevHasFocus, prevSuccessfulEdit]);
  const { tabIndex: editActivateTabIndex } = useSingleTabStopNavigation(editActivateRef);
  return import_react17.default.createElement(TableTdElement, Object.assign({}, rest, { nativeAttributes: tdNativeAttributes, className: clsx_m_default(className, styles_css_default6["body-cell-editable"], interactiveCell && styles_css_default6["body-cell-interactive"], isEditing && styles_css_default6["body-cell-edit-active"], showSuccessIcon && showIcon && styles_css_default6["body-cell-has-success"], isVisualRefresh && styles_css_default6["is-visual-refresh"]), onClick: interactiveCell && !isEditing ? onEditStart : void 0, onMouseEnter: () => setHasHover(true), onMouseLeave: () => setHasHover(false) }), isEditing ? import_react17.default.createElement(InlineEditor, { ariaLabels, column, item, onEditEnd: (options) => {
    setShowSuccessIcon(false);
    isFocusMoveNeededRef.current = options.refocusCell;
    onEditEnd(options.cancelled);
  }, submitEdit: submitEdit !== null && submitEdit !== void 0 ? submitEdit : submitHandlerFallback }) : import_react17.default.createElement(
    import_react17.default.Fragment,
    null,
    column.cell(item),
    showSuccessIcon && showIcon && import_react17.default.createElement(
      import_react17.default.Fragment,
      null,
      import_react17.default.createElement(
        "span",
        { className: styles_css_default6["body-cell-success"], "aria-label": (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.successfulEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column), role: "img", onMouseDown: (e) => {
          e.preventDefault();
        } },
        import_react17.default.createElement(internal_default, { name: "status-positive", variant: "success" })
      ),
      import_react17.default.createElement(live_region_default, null, i18n("ariaLabels.successfulEditLabel", (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.successfulEditLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, column)))
    ),
    import_react17.default.createElement(
      "div",
      { className: styles_css_default6["body-cell-editor-wrapper"] },
      import_react17.default.createElement("button", { className: styles_css_default6["body-cell-editor"], "aria-label": (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, column, item), ref: editActivateRef, onClick: !interactiveCell && !isEditing ? onEditStart : void 0, onFocus: () => setHasFocus(true), onBlur: () => setHasFocus(false), tabIndex: editActivateTabIndex }, showIcon && import_react17.default.createElement(internal_default, { name: "edit" }))
    )
  ));
}
function TableBodyCell(_a) {
  var _b, _c;
  var { isEditable } = _a, rest = __rest(_a, ["isEditable"]);
  const editDisabledReason = (_c = (_b = rest.column.editConfig) === null || _b === void 0 ? void 0 : _b.disabledReason) === null || _c === void 0 ? void 0 : _c.call(_b, rest.item);
  if (editDisabledReason) {
    return import_react17.default.createElement(DisabledInlineEditor, Object.assign({ editDisabledReason }, rest));
  }
  if (isEditable || rest.isEditing) {
    return import_react17.default.createElement(TableCellEditable, Object.assign({}, rest));
  }
  const { column, item } = rest;
  return import_react17.default.createElement(TableTdElement, Object.assign({}, rest), column.cell(item));
}

// node_modules/@cloudscape-design/components/table/use-row-events.js
function useRowEvents({ onRowClick, onRowContextMenu }) {
  const onRowClickHandler = (rowIndex, item, event) => {
    const tableCell = findUpUntil2(event.target, (element) => element.tagName.toLowerCase() === "td");
    if (!tableCell || !tableCell.classList.contains(styles_css_default2["selection-control"])) {
      const details = { rowIndex, item };
      fireNonCancelableEvent(onRowClick, details);
    }
  };
  const onRowContextMenuHandler = (rowIndex, item, event) => {
    const details = {
      rowIndex,
      item,
      clientX: event.clientX,
      clientY: event.clientY
    };
    fireCancelableEvent(onRowContextMenu, details, event);
  };
  return {
    onRowClickHandler: onRowClick && onRowClickHandler,
    onRowContextMenuHandler: onRowContextMenu && onRowContextMenuHandler
  };
}

// node_modules/@cloudscape-design/components/internal/hooks/use-scroll-sync/index.js
var import_react18 = __toESM(require_react());
function useScrollSync(refs, disabled = !supportsStickyPosition()) {
  const activeElement = (0, import_react18.useRef)(null);
  const onScroll = (event) => {
    const targetElement = event.currentTarget;
    if (targetElement && (activeElement.current === null || activeElement.current === targetElement)) {
      requestAnimationFrame(() => {
        activeElement.current = targetElement;
        refs.forEach((ref) => {
          const element = ref.current;
          if (element && element !== targetElement) {
            element.scrollLeft = targetElement.scrollLeft;
          }
        });
        requestAnimationFrame(() => {
          activeElement.current = null;
        });
      });
    }
  };
  return !disabled ? onScroll : void 0;
}

// node_modules/@cloudscape-design/components/table/sticky-header.js
var import_react20 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/use-sticky-header.js
var import_react19 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrolling.js
function stickyScrolling(containerRef, stickyRef) {
  const scrollToTop = () => {
    if (!containerRef.current || !stickyRef.current) {
      return;
    }
    const scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);
    if (scrollingOffset > 0) {
      scrollUpBy(scrollingOffset, containerRef.current);
    }
  };
  const scrollToItem = (item) => {
    if (!item || !containerRef.current || !stickyRef.current) {
      return;
    }
    const stickyBottom = stickyRef.current.getBoundingClientRect().bottom;
    const scrollingOffset = stickyBottom - item.getBoundingClientRect().top;
    if (scrollingOffset > 0) {
      scrollUpBy(scrollingOffset, containerRef.current);
    }
  };
  return {
    scrollToTop,
    scrollToItem
  };
}
function calculateScrollingOffset(container, sticky) {
  const stickyRect = sticky.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  return stickyRect.top - containerRect.top;
}
function scrollUpBy(amount, container) {
  const parent = getOverflowParents(container);
  if (parent.length) {
    parent[0].scrollTop -= amount;
  } else {
    window.scrollTo({ top: window.pageYOffset - amount });
  }
}

// node_modules/@cloudscape-design/components/table/use-sticky-header.js
var useStickyHeader = (tableRef, theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef) => {
  const isMobile = useMobile();
  const syncColumnHeaderWidths = (0, import_react19.useCallback)(() => {
    if (tableRef.current && theadRef.current && secondaryTheadRef.current && secondaryTableRef.current && tableWrapperRef.current) {
      secondaryTableRef.current.style.width = `${tableRef.current.offsetWidth}px`;
      tableWrapperRef.current.style.marginTop = `-${theadRef.current.offsetHeight}px`;
    }
  }, [theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef, tableRef]);
  (0, import_react19.useLayoutEffect)(() => {
    syncColumnHeaderWidths();
  });
  useResizeObserver(theadRef, syncColumnHeaderWidths);
  const scrollToTop = () => {
    if (!isMobile && theadRef.current && secondaryTheadRef.current && tableWrapperRef.current) {
      const scrollDist = calculateScrollingOffset(theadRef.current, secondaryTheadRef.current);
      if (scrollDist > 0) {
        scrollUpBy(scrollDist, tableWrapperRef.current);
      }
    }
  };
  const { scrollToItem } = stickyScrolling(tableWrapperRef, secondaryTheadRef);
  const scrollToRow = (itemNode) => {
    if (!isMobile) {
      scrollToItem(itemNode);
    }
  };
  return { scrollToRow, scrollToTop };
};

// node_modules/@cloudscape-design/components/table/sticky-header.js
var sticky_header_default = (0, import_react20.forwardRef)(StickyHeader);
function StickyHeader({ variant, theadProps, wrapperRef, theadRef, secondaryWrapperRef, onScroll, tableRef, tableHasHeader, contentDensity, tableRole }, ref) {
  const secondaryTheadRef = (0, import_react20.useRef)(null);
  const secondaryTableRef = (0, import_react20.useRef)(null);
  const { isStuck } = (0, import_react20.useContext)(StickyHeaderContext);
  const [focusedComponent, setFocusedComponent] = (0, import_react20.useState)(null);
  const { scrollToRow, scrollToTop } = useStickyHeader(tableRef, theadRef, secondaryTheadRef, secondaryTableRef, wrapperRef);
  (0, import_react20.useImperativeHandle)(ref, () => ({
    scrollToTop,
    scrollToRow,
    setFocus: setFocusedComponent
  }));
  return import_react20.default.createElement(
    "div",
    {
      className: clsx_m_default(styles_css_default2["header-secondary"], styles_css_default2[`variant-${variant}`], {
        [styles_css_default2.stuck]: isStuck,
        [styles_css_default2["table-has-header"]]: tableHasHeader
      }),
      "aria-hidden": true,
      // Prevents receiving focus in Firefox. Focus on the overflowing table is sufficient
      // to scroll the table horizontally
      tabIndex: -1,
      ref: secondaryWrapperRef,
      onScroll
    },
    import_react20.default.createElement(
      "table",
      Object.assign({ className: clsx_m_default(styles_css_default2.table, styles_css_default2["table-layout-fixed"], contentDensity === "compact" && getVisualContextClassname("compact-table")), ref: secondaryTableRef }, getTableRoleProps({ tableRole })),
      import_react20.default.createElement(thead_default, Object.assign({ ref: secondaryTheadRef, sticky: true, stuck: isStuck, focusedComponent }, theadProps))
    )
  );
}

// node_modules/@cloudscape-design/components/internal/hooks/use-mouse-down-target.js
var import_react21 = __toESM(require_react());
var useEventListenersSingleton = createSingletonHandler((setTarget) => {
  function handleMouseDown(event) {
    setTarget(event.target);
  }
  function handleKeyDown() {
    setTarget(null);
  }
  window.addEventListener("mousedown", handleMouseDown);
  window.addEventListener("keydown", handleKeyDown);
  return () => {
    window.removeEventListener("mousedown", handleMouseDown);
    window.removeEventListener("keydown", handleKeyDown);
  };
});
function useMouseDownTarget() {
  const mouseDownTargetRef = (0, import_react21.useRef)(null);
  useEventListenersSingleton((target) => {
    mouseDownTargetRef.current = target;
  });
  return () => mouseDownTargetRef.current;
}

// node_modules/@cloudscape-design/components/table/use-table-focus-navigation.js
var import_react22 = __toESM(require_react());
function iterateTableCells(table, func) {
  table.querySelectorAll("tr").forEach((row, rowIndex) => {
    row.querySelectorAll("td").forEach((cell, cellIndex) => {
      func(cell, rowIndex, cellIndex);
    });
  });
}
function useTableFocusNavigation({ tableRole, selectionType, tableRoot, columnDefinitions, numRows }) {
  const focusableColumns = (0, import_react22.useMemo)(() => {
    const cols = columnDefinitions.map((column) => !!column.editConfig);
    if (selectionType) {
      cols.unshift(false);
    }
    return cols;
  }, [columnDefinitions, selectionType]);
  const maxColumnIndex = focusableColumns.length - 1;
  const minColumnIndex = selectionType ? 1 : 0;
  const focusCell = (0, import_react22.useCallback)((rowIndex, columnIndex) => {
    if (tableRoot === null || tableRoot === void 0 ? void 0 : tableRoot.current) {
      iterateTableCells(tableRoot.current, (cell, rIndex, cIndex) => {
        var _a;
        if (rIndex === rowIndex && cIndex === columnIndex) {
          const editButton = cell.querySelector("button:last-child");
          if (editButton) {
            (_a = editButton.focus) === null || _a === void 0 ? void 0 : _a.call(editButton);
            scrollElementIntoView(editButton);
          }
        }
      });
    }
  }, [tableRoot]);
  const shiftFocus = (0, import_react22.useCallback)((vertical, horizontal) => {
    var _a;
    const focusedCell = (_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector("td:focus-within");
    if (!focusedCell) {
      return;
    }
    const columnIndex = focusedCell.cellIndex;
    const rowIndex = focusedCell.parentElement.rowIndex;
    let newRowIndex = rowIndex;
    let newColumnIndex = columnIndex;
    if (vertical !== 0) {
      newRowIndex = Math.min(numRows, Math.max(rowIndex + vertical, 0));
    }
    if (horizontal !== 0) {
      while (newColumnIndex <= maxColumnIndex && newColumnIndex >= minColumnIndex) {
        newColumnIndex += horizontal;
        if (focusableColumns[newColumnIndex]) {
          break;
        }
      }
    }
    if ((rowIndex !== newRowIndex || columnIndex !== newColumnIndex) && tableRoot.current) {
      focusCell(newRowIndex, newColumnIndex);
    }
  }, [focusCell, focusableColumns, maxColumnIndex, minColumnIndex, numRows, tableRoot]);
  const handleArrowKeyEvents = (0, import_react22.useCallback)((event) => {
    var _a, _b;
    const abort = !!((_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector('[data-inline-editing-active = "true"]')) || !((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.closest("[data-inline-editing-active]"));
    if (abort) {
      return;
    }
    switch (event.key) {
      case "ArrowUp":
        event.preventDefault();
        shiftFocus(-1, 0);
        break;
      case "ArrowDown":
        event.preventDefault();
        shiftFocus(1, 0);
        break;
      case "ArrowLeft":
        event.preventDefault();
        shiftFocus(0, -1);
        break;
      case "ArrowRight":
        event.preventDefault();
        shiftFocus(0, 1);
        break;
      default:
        return;
    }
  }, [shiftFocus, tableRoot]);
  (0, import_react22.useEffect)(() => {
    if (!tableRoot.current || tableRole === "grid") {
      return;
    }
    const tableElement = tableRoot.current;
    tableRoot.current.addEventListener("keydown", handleArrowKeyEvents);
    return () => tableElement && tableElement.removeEventListener("keydown", handleArrowKeyEvents);
  }, [tableRole, focusableColumns, handleArrowKeyEvents, tableRoot]);
}
var use_table_focus_navigation_default = useTableFocusNavigation;

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/sticky-scrollbar.js
var import_react24 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/use-sticky-scrollbar.js
var import_react23 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/styles.css.js
import "/home/bryanchasko/code/rgc3/node_modules/@cloudscape-design/components/table/sticky-scrollbar/styles.scoped.css";
var styles_css_default7 = {
  "sticky-scrollbar": "awsui_sticky-scrollbar_faqt8_xxk3x_99",
  "sticky-scrollbar-content": "awsui_sticky-scrollbar-content_faqt8_xxk3x_108",
  "sticky-scrollbar-visible": "awsui_sticky-scrollbar-visible_faqt8_xxk3x_111",
  "sticky-scrollbar-native-invisible": "awsui_sticky-scrollbar-native-invisible_faqt8_xxk3x_114",
  "sticky-scrollbar-offset": "awsui_sticky-scrollbar-offset_faqt8_xxk3x_117",
  "is-visual-refresh": "awsui_is-visual-refresh_faqt8_xxk3x_120"
};

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/use-sticky-scrollbar.js
var updatePosition = (tableEl, wrapperEl, scrollbarEl, scrollbarContentEl, hasContainingBlock, consideredFooterHeight) => {
  if (!tableEl || !scrollbarEl || !wrapperEl) {
    return;
  }
  const { width: tableWidth } = tableEl.getBoundingClientRect();
  const { width: wrapperWidth } = wrapperEl.getBoundingClientRect();
  const scrollbarHeight = browserScrollbarSize().height;
  const areaIsScrollable = tableWidth > wrapperWidth;
  if (!areaIsScrollable) {
    scrollbarEl.classList.remove(styles_css_default7["sticky-scrollbar-visible"]);
  } else {
    if (!scrollbarEl.classList.contains(styles_css_default7["sticky-scrollbar-visible"])) {
      requestAnimationFrame(() => {
        scrollbarEl.scrollLeft = wrapperEl.scrollLeft;
      });
    }
    scrollbarEl.classList.add(styles_css_default7["sticky-scrollbar-visible"]);
    if (!scrollbarHeight) {
      scrollbarEl.classList.add(styles_css_default7["sticky-scrollbar-native-invisible"]);
    }
  }
  if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {
    scrollbarEl.style.height = `${scrollbarHeight}px`;
    scrollbarContentEl.style.height = `${scrollbarHeight}px`;
  }
  if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {
    const wrapperElRect = wrapperEl.getBoundingClientRect();
    const tableElRect = tableEl.getBoundingClientRect();
    scrollbarEl.style.width = `${wrapperElRect.width}px`;
    scrollbarContentEl.style.width = `${tableElRect.width}px`;
    scrollbarEl.style.bottom = hasContainingBlock ? "0px" : `${consideredFooterHeight}px`;
  }
};
function useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, footerHeight, offsetScrollbar) {
  const [hasContainingBlock, setHasContainingBlock] = (0, import_react23.useState)(false);
  const [hasOverflowParent, setHasOverflowParent] = (0, import_react23.useState)(false);
  const consideredFooterHeight = hasContainingBlock || hasOverflowParent ? 0 : footerHeight;
  const wrapperEl = wrapperRef.current;
  (0, import_react23.useEffect)(() => {
    if (wrapperEl && supportsStickyPosition()) {
      setHasContainingBlock(!!getContainingBlock(wrapperEl));
      setHasOverflowParent(!!getOverflowParents(wrapperEl)[0]);
    }
  }, [wrapperEl]);
  (0, import_react23.useEffect)(() => {
    if (supportsStickyPosition() && wrapperRef.current && tableRef.current) {
      const observer = new ResizeObserver(() => {
        if (scrollbarContentRef.current) {
          updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
        }
      });
      observer.observe(wrapperRef.current);
      observer.observe(tableRef.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [
    scrollbarContentRef,
    scrollbarRef,
    tableRef,
    wrapperRef,
    consideredFooterHeight,
    hasContainingBlock,
    offsetScrollbar
  ]);
  (0, import_react23.useEffect)(() => {
    if (supportsStickyPosition()) {
      const resizeHandler = () => {
        updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
      };
      resizeHandler();
      window.addEventListener("resize", resizeHandler);
      return () => {
        window.removeEventListener("resize", resizeHandler);
      };
    }
  }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, hasContainingBlock, consideredFooterHeight]);
}

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/sticky-scrollbar.js
var sticky_scrollbar_default = (0, import_react24.forwardRef)(StickyScrollbar);
function StickyScrollbar({ wrapperRef, tableRef, onScroll, hasStickyColumns }, ref) {
  const isVisualRefresh = useVisualRefresh();
  const scrollbarRef = import_react24.default.useRef(null);
  const scrollbarContentRef = import_react24.default.useRef(null);
  const mergedRef = useMergeRefs(ref, scrollbarRef);
  const offsetScrollbar = hasStickyColumns || browserScrollbarSize().height === 0;
  const { stickyOffsetBottom } = useAppLayoutContext();
  useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, stickyOffsetBottom, offsetScrollbar);
  return import_react24.default.createElement(
    "div",
    { ref: mergedRef, className: clsx_m_default(styles_css_default7["sticky-scrollbar"], offsetScrollbar && styles_css_default7["sticky-scrollbar-offset"], isVisualRefresh && styles_css_default7["is-visual-refresh"]), onScroll },
    import_react24.default.createElement("div", { ref: scrollbarContentRef, className: styles_css_default7["sticky-scrollbar-content"] })
  );
}

// node_modules/@cloudscape-design/components/table/use-cell-editing.js
var import_react25 = __toESM(require_react());
function useCellEditing({ onCancel, onSubmit }) {
  const [currentEditCell, setCurrentEditCell] = (0, import_react25.useState)(null);
  const [lastSuccessfulEditCell, setLastSuccessfulEditCell] = (0, import_react25.useState)(null);
  const [currentEditLoading, setCurrentEditLoading] = (0, import_react25.useState)(false);
  const startEdit = (cellId) => {
    setLastSuccessfulEditCell(null);
    setCurrentEditCell(cellId);
  };
  const cancelEdit = (0, import_react25.useCallback)(() => setCurrentEditCell(null), []);
  const completeEdit = (cellId, editCancelled) => {
    const eventCancelled = fireCancelableEvent(onCancel, {});
    if (!eventCancelled) {
      setCurrentEditCell(null);
      if (!editCancelled) {
        setLastSuccessfulEditCell(cellId);
      }
    }
  };
  const checkEditing = ({ rowIndex, colIndex }) => rowIndex === (currentEditCell === null || currentEditCell === void 0 ? void 0 : currentEditCell.rowIndex) && colIndex === currentEditCell.colIndex;
  const checkLastSuccessfulEdit = ({ rowIndex, colIndex }) => rowIndex === (lastSuccessfulEditCell === null || lastSuccessfulEditCell === void 0 ? void 0 : lastSuccessfulEditCell.rowIndex) && colIndex === lastSuccessfulEditCell.colIndex;
  const submitEdit = onSubmit ? (...args) => __awaiter(this, void 0, void 0, function* () {
    setCurrentEditLoading(true);
    try {
      yield onSubmit(...args);
    } finally {
      setCurrentEditLoading(false);
    }
  }) : void 0;
  return {
    isLoading: currentEditLoading,
    startEdit,
    cancelEdit,
    checkEditing,
    checkLastSuccessfulEdit,
    completeEdit,
    submitEdit
  };
}

// node_modules/@cloudscape-design/components/table/no-data-cell.js
var import_react26 = __toESM(require_react());
function NoDataCell({ totalColumnsCount, hasFooter, loading, loadingText, empty, tableRef, containerRef }) {
  const cellContentRef = (0, import_react26.useRef)(null);
  useResizeObserver(containerRef, ({ contentBoxWidth: containerWidth }) => {
    if (tableRef.current && cellContentRef.current && supportsStickyPosition()) {
      const tablePaddingLeft = parseFloat(getComputedStyle(tableRef.current).paddingLeft) || 0;
      const tablePaddingRight = parseFloat(getComputedStyle(tableRef.current).paddingRight) || 0;
      const contentWidth = containerWidth + tablePaddingLeft + tablePaddingRight;
      cellContentRef.current.style.width = Math.floor(contentWidth) + "px";
    }
  });
  return import_react26.default.createElement(
    "td",
    { colSpan: totalColumnsCount, className: clsx_m_default(styles_css_default2["cell-merged"], hasFooter && styles_css_default2["has-footer"]) },
    import_react26.default.createElement("div", { ref: cellContentRef, className: styles_css_default2["cell-merged-content"], "data-awsui-table-suppress-navigation": true }, loading ? import_react26.default.createElement(
      StatusIndicator,
      { type: "loading", className: styles_css_default2.loading, wrapText: true },
      import_react26.default.createElement(live_region_default, { visible: true }, loadingText)
    ) : import_react26.default.createElement("div", { className: styles_css_default2.empty }, empty))
  );
}

// node_modules/@cloudscape-design/components/table/internal.js
var GRID_NAVIGATION_PAGE_SIZE = 10;
var SELECTION_COLUMN_WIDTH = 54;
var selectionColumnId = Symbol("selection-column-id");
var InternalTableAsSubstep = import_react27.default.forwardRef((props, ref) => {
  const { funnelSubStepProps } = useFunnelSubStep();
  const tableProps = Object.assign(Object.assign({}, props), { __funnelSubStepProps: funnelSubStepProps });
  return import_react27.default.createElement(InternalTable, Object.assign({}, tableProps, { ref }));
});
var InternalTable = import_react27.default.forwardRef((_a, ref) => {
  var _b, _c, _d, _e, _f;
  var { header, footer, empty, filter, pagination, preferences, items, columnDefinitions, trackBy, loading, loadingText, selectionType, selectedItems, isItemDisabled, ariaLabels, onSelectionChange, onSortingChange, sortingColumn, sortingDescending, sortingDisabled, visibleColumns, stickyHeader, stickyHeaderVerticalOffset, onRowClick, onRowContextMenu, wrapLines, stripedRows, contentDensity, submitEdit, onEditCancel, resizableColumns, onColumnWidthsChange, variant, __internalRootRef, totalItemsCount, firstIndex, renderAriaLive, stickyColumns, columnDisplay, enableKeyboardNavigation = false, __funnelSubStepProps } = _a, rest = __rest(_a, ["header", "footer", "empty", "filter", "pagination", "preferences", "items", "columnDefinitions", "trackBy", "loading", "loadingText", "selectionType", "selectedItems", "isItemDisabled", "ariaLabels", "onSelectionChange", "onSortingChange", "sortingColumn", "sortingDescending", "sortingDisabled", "visibleColumns", "stickyHeader", "stickyHeaderVerticalOffset", "onRowClick", "onRowContextMenu", "wrapLines", "stripedRows", "contentDensity", "submitEdit", "onEditCancel", "resizableColumns", "onColumnWidthsChange", "variant", "__internalRootRef", "totalItemsCount", "firstIndex", "renderAriaLive", "stickyColumns", "columnDisplay", "enableKeyboardNavigation", "__funnelSubStepProps"]);
  const baseProps = getBaseProps(rest);
  stickyHeader = stickyHeader && supportsStickyPosition();
  const isMobile = useMobile();
  const [containerWidth, wrapperMeasureRef] = useContainerQuery((rect) => rect.contentBoxWidth);
  const wrapperMeasureRefObject = (0, import_react27.useRef)(null);
  const wrapperMeasureMergedRef = useMergeRefs(wrapperMeasureRef, wrapperMeasureRefObject);
  const [tableWidth, tableMeasureRef] = useContainerQuery((rect) => rect.contentBoxWidth);
  const tableRefObject = (0, import_react27.useRef)(null);
  const secondaryWrapperRef = import_react27.default.useRef(null);
  const theadRef = (0, import_react27.useRef)(null);
  const stickyHeaderRef = import_react27.default.useRef(null);
  const scrollbarRef = import_react27.default.useRef(null);
  const _g = useCellEditing({ onCancel: onEditCancel, onSubmit: submitEdit }), { cancelEdit } = _g, cellEditing = __rest(_g, ["cancelEdit"]);
  usePerformanceMarks("table", true, tableRefObject, () => {
    var _a2, _b2, _c2, _d2;
    const headerText = (_c2 = (_b2 = (_a2 = toolsHeaderWrapper.current) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`.${styles_css_default["heading-text"]}`)) === null || _b2 === void 0 ? void 0 : _b2.innerText) !== null && _c2 !== void 0 ? _c2 : (_d2 = toolsHeaderWrapper.current) === null || _d2 === void 0 ? void 0 : _d2.innerText;
    return {
      loading: loading !== null && loading !== void 0 ? loading : false,
      header: headerText
    };
  }, [loading]);
  (0, import_react27.useImperativeHandle)(ref, () => {
    var _a2;
    return {
      scrollToTop: ((_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollToTop) || (() => void 0),
      cancelEdit
    };
  }, [cancelEdit]);
  const wrapperRefObject = (0, import_react27.useRef)(null);
  const handleScroll = useScrollSync([wrapperRefObject, scrollbarRef, secondaryWrapperRef]);
  const { moveFocusDown, moveFocusUp, moveFocus } = useSelectionFocusMove(selectionType, items.length);
  const { onRowClickHandler, onRowContextMenuHandler } = useRowEvents({ onRowClick, onRowContextMenu });
  const visibleColumnDefinitions = getVisibleColumnDefinitions({
    columnDefinitions,
    columnDisplay,
    visibleColumns
  });
  const { isItemSelected, getSelectAllProps, getItemSelectionProps, updateShiftToggle } = useSelection({
    items,
    trackBy,
    selectedItems,
    selectionType,
    isItemDisabled,
    onSelectionChange,
    ariaLabels,
    loading
  });
  if (isDevelopment) {
    if (resizableColumns) {
      checkColumnWidths(columnDefinitions);
    }
    if (sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingComparator) {
      checkSortingState(columnDefinitions, sortingColumn.sortingComparator);
    }
  }
  const isVisualRefresh = useVisualRefresh();
  const computedVariant = isVisualRefresh ? variant : ["embedded", "full-page"].indexOf(variant) > -1 ? "container" : variant;
  const hasHeader = !!(header || filter || pagination || preferences);
  const hasSelection = !!selectionType;
  const hasFooterPagination = isMobile && variant === "full-page" && !!pagination;
  const hasFooter = !!footer || hasFooterPagination;
  const headerIdRef = (0, import_react27.useRef)(void 0);
  const isLabelledByHeader = !(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel) && !!header;
  const setHeaderRef = (0, import_react27.useCallback)((id) => {
    headerIdRef.current = id;
  }, []);
  const visibleColumnWidthsWithSelection = [];
  const visibleColumnIdsWithSelection = [];
  if (hasSelection) {
    visibleColumnWidthsWithSelection.push({ id: selectionColumnId, width: SELECTION_COLUMN_WIDTH });
    visibleColumnIdsWithSelection.push(selectionColumnId);
  }
  for (let columnIndex = 0; columnIndex < visibleColumnDefinitions.length; columnIndex++) {
    const columnId = getColumnKey(visibleColumnDefinitions[columnIndex], columnIndex);
    visibleColumnWidthsWithSelection.push(Object.assign(Object.assign({}, visibleColumnDefinitions[columnIndex]), { id: columnId }));
    visibleColumnIdsWithSelection.push(columnId);
  }
  const stickyState = useStickyColumns({
    visibleColumns: visibleColumnIdsWithSelection,
    stickyColumnsFirst: ((_b = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) !== null && _b !== void 0 ? _b : 0) + ((stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) && hasSelection ? 1 : 0),
    stickyColumnsLast: (stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.last) || 0
  });
  const hasStickyColumns = !!(((_c = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) !== null && _c !== void 0 ? _c : 0) + ((_d = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.last) !== null && _d !== void 0 ? _d : 0) > 0);
  const hasEditableCells = !!columnDefinitions.find((col) => col.editConfig);
  const tableRole = enableKeyboardNavigation ? "grid" : hasEditableCells ? "grid-default" : "table";
  const theadProps = {
    selectionType,
    getSelectAllProps,
    columnDefinitions: visibleColumnDefinitions,
    variant: computedVariant,
    wrapLines,
    resizableColumns,
    sortingColumn,
    sortingDisabled,
    sortingDescending,
    onSortingChange,
    onFocusMove: moveFocus,
    onResizeFinish(newWidth) {
      const widthsDetail = columnDefinitions.map((column, index) => newWidth.get(getColumnKey(column, index)) || column.width || DEFAULT_COLUMN_WIDTH);
      const widthsChanged = widthsDetail.some((width, index) => columnDefinitions[index].width !== width);
      if (widthsChanged) {
        fireNonCancelableEvent(onColumnWidthsChange, { widths: widthsDetail });
      }
    },
    singleSelectionHeaderAriaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel,
    resizerRoleDescription: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.resizerRoleDescription,
    stripedRows,
    stickyState,
    selectionColumnId,
    tableRole
  };
  const wrapperRef = useMergeRefs(wrapperRefObject, stickyState.refs.wrapper);
  const tableRef = useMergeRefs(tableMeasureRef, tableRefObject, stickyState.refs.table);
  const wrapperProps = getTableWrapperRoleProps({
    tableRole,
    isScrollable: !!(tableWidth && containerWidth && tableWidth > containerWidth),
    ariaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel
  });
  const getMouseDownTarget = useMouseDownTarget();
  const hasDynamicHeight = computedVariant === "full-page";
  const overlapElement = useDynamicOverlap({ disabled: !hasDynamicHeight });
  use_table_focus_navigation_default({
    tableRole,
    selectionType,
    tableRoot: tableRefObject,
    columnDefinitions: visibleColumnDefinitions,
    numRows: items === null || items === void 0 ? void 0 : items.length
  });
  const toolsHeaderWrapper = (0, import_react27.useRef)(null);
  const toolsHeaderHeight = (_f = (_e = toolsHeaderWrapper === null || toolsHeaderWrapper === void 0 ? void 0 : toolsHeaderWrapper.current) === null || _e === void 0 ? void 0 : _e.getBoundingClientRect().height) !== null && _f !== void 0 ? _f : 0;
  const totalColumnsCount = selectionType ? visibleColumnDefinitions.length + 1 : visibleColumnDefinitions.length;
  return import_react27.default.createElement(
    LinkDefaultVariantContext.Provider,
    { value: { defaultVariant: "primary" } },
    import_react27.default.createElement(
      ColumnWidthsProvider,
      { visibleColumns: visibleColumnWidthsWithSelection, resizableColumns, containerRef: wrapperMeasureRefObject },
      import_react27.default.createElement(
        InternalContainer,
        Object.assign({}, baseProps, { __internalRootRef, className: clsx_m_default(baseProps.className, styles_css_default2.root), __funnelSubStepProps, header: import_react27.default.createElement(
          import_react27.default.Fragment,
          null,
          hasHeader && import_react27.default.createElement(
            "div",
            { ref: overlapElement, className: clsx_m_default(hasDynamicHeight && [styles_css_default2["dark-header"], getContentHeaderClassName()]) },
            import_react27.default.createElement(
              "div",
              { ref: toolsHeaderWrapper, className: clsx_m_default(styles_css_default2["header-controls"], styles_css_default2[`variant-${computedVariant}`]) },
              import_react27.default.createElement(
                CollectionLabelContext.Provider,
                { value: { assignId: setHeaderRef } },
                import_react27.default.createElement(ToolsHeader, { header, filter, pagination, preferences })
              )
            )
          ),
          stickyHeader && import_react27.default.createElement(sticky_header_default, { ref: stickyHeaderRef, variant: computedVariant, theadProps, wrapperRef: wrapperRefObject, theadRef, secondaryWrapperRef, tableRef: tableRefObject, onScroll: handleScroll, tableHasHeader: hasHeader, contentDensity, tableRole })
        ), disableHeaderPaddings: true, disableContentPaddings: true, variant: toContainerVariant(computedVariant), __disableFooterPaddings: true, __disableFooterDivider: true, __disableStickyMobile: false, footer: hasFooter ? import_react27.default.createElement(
          "div",
          { className: clsx_m_default(styles_css_default2["footer-wrapper"], styles_css_default2[`variant-${computedVariant}`]) },
          import_react27.default.createElement(
            "div",
            { className: clsx_m_default(styles_css_default2.footer, hasFooterPagination && styles_css_default2["footer-with-pagination"]) },
            footer && import_react27.default.createElement("span", null, footer),
            hasFooterPagination && import_react27.default.createElement("div", { className: styles_css_default2["footer-pagination"] }, pagination)
          )
        ) : null, __stickyHeader: stickyHeader, __mobileStickyOffset: toolsHeaderHeight, __stickyOffset: stickyHeaderVerticalOffset }, focusMarkers.root),
        import_react27.default.createElement(
          "div",
          Object.assign({ ref: wrapperRef, className: clsx_m_default(styles_css_default2.wrapper, styles_css_default2[`variant-${computedVariant}`], {
            [styles_css_default2["has-footer"]]: hasFooter,
            [styles_css_default2["has-header"]]: hasHeader
          }), style: stickyState.style.wrapper, onScroll: handleScroll }, wrapperProps),
          import_react27.default.createElement("div", { className: styles_css_default2["wrapper-content-measure"], ref: wrapperMeasureMergedRef }),
          !!renderAriaLive && !!firstIndex && import_react27.default.createElement(
            live_region_default,
            null,
            import_react27.default.createElement("span", null, renderAriaLive({ totalItemsCount, firstIndex, lastIndex: firstIndex + items.length - 1 }))
          ),
          import_react27.default.createElement(
            GridNavigationProvider,
            { keyboardNavigation: tableRole === "grid", pageSize: GRID_NAVIGATION_PAGE_SIZE, getTable: () => tableRefObject.current },
            import_react27.default.createElement(
              "table",
              Object.assign({ ref: tableRef, className: clsx_m_default(styles_css_default2.table, resizableColumns && styles_css_default2["table-layout-fixed"], contentDensity === "compact" && getVisualContextClassname("compact-table")) }, getTableRoleProps({
                tableRole,
                totalItemsCount,
                totalColumnsCount,
                ariaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel,
                ariaLabelledBy: isLabelledByHeader && headerIdRef.current ? headerIdRef.current : void 0
              })),
              import_react27.default.createElement(thead_default, Object.assign({ ref: theadRef, hidden: stickyHeader, onFocusedComponentChange: (focusId) => {
                var _a2;
                return (_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.setFocus(focusId);
              } }, theadProps)),
              import_react27.default.createElement("tbody", null, loading || items.length === 0 ? import_react27.default.createElement(
                "tr",
                null,
                import_react27.default.createElement(NoDataCell, { totalColumnsCount, hasFooter, loading, loadingText, empty, tableRef: tableRefObject, containerRef: wrapperMeasureRefObject })
              ) : items.map((item, rowIndex) => {
                const firstVisible = rowIndex === 0;
                const lastVisible = rowIndex === items.length - 1;
                const isEven = rowIndex % 2 === 0;
                const isSelected = !!selectionType && isItemSelected(item);
                const isPrevSelected = !!selectionType && !firstVisible && isItemSelected(items[rowIndex - 1]);
                const isNextSelected = !!selectionType && !lastVisible && isItemSelected(items[rowIndex + 1]);
                return import_react27.default.createElement(
                  "tr",
                  Object.assign({ key: getItemKey(trackBy, item, rowIndex), className: clsx_m_default(styles_css_default2.row, isSelected && styles_css_default2["row-selected"]), onFocus: ({ currentTarget }) => {
                    var _a2;
                    if (!currentTarget.contains(getMouseDownTarget())) {
                      (_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollToRow(currentTarget);
                    }
                  } }, focusMarkers.item, { onClick: onRowClickHandler && onRowClickHandler.bind(null, rowIndex, item), onContextMenu: onRowContextMenuHandler && onRowContextMenuHandler.bind(null, rowIndex, item) }, getTableRowRoleProps({ tableRole, firstIndex, rowIndex })),
                  selectionType !== void 0 && import_react27.default.createElement(
                    TableTdElement,
                    { className: clsx_m_default(styles_css_default2["selection-control"]), isVisualRefresh, isFirstRow: firstVisible, isLastRow: lastVisible, isSelected, isNextSelected, isPrevSelected, wrapLines: false, isEvenRow: isEven, stripedRows, hasSelection, hasFooter, stickyState, columnId: selectionColumnId, colIndex: 0, tableRole },
                    import_react27.default.createElement(SelectionControl, Object.assign({ tableRole, onFocusDown: moveFocusDown, onFocusUp: moveFocusUp, onShiftToggle: updateShiftToggle }, getItemSelectionProps(item)))
                  ),
                  visibleColumnDefinitions.map((column, colIndex) => {
                    var _a2;
                    const isEditing = cellEditing.checkEditing({ rowIndex, colIndex });
                    const successfulEdit = cellEditing.checkLastSuccessfulEdit({ rowIndex, colIndex });
                    const isEditable = !!column.editConfig && !cellEditing.isLoading;
                    return import_react27.default.createElement(TableBodyCell, { key: getColumnKey(column, colIndex), style: resizableColumns ? {} : {
                      width: column.width,
                      minWidth: column.minWidth,
                      maxWidth: column.maxWidth
                    }, ariaLabels, column, item, wrapLines, isEditable, isEditing, isRowHeader: column.isRowHeader, isFirstRow: firstVisible, isLastRow: lastVisible, isSelected, isNextSelected, isPrevSelected, successfulEdit, onEditStart: () => cellEditing.startEdit({ rowIndex, colIndex }), onEditEnd: (editCancelled) => cellEditing.completeEdit({ rowIndex, colIndex }, editCancelled), submitEdit: cellEditing.submitEdit, hasFooter, stripedRows, isEvenRow: isEven, columnId: (_a2 = column.id) !== null && _a2 !== void 0 ? _a2 : colIndex, colIndex: selectionType !== void 0 ? colIndex + 1 : colIndex, stickyState, isVisualRefresh, tableRole });
                  })
                );
              }))
            )
          ),
          resizableColumns && import_react27.default.createElement(ResizeTracker, null)
        ),
        import_react27.default.createElement(sticky_scrollbar_default, { ref: scrollbarRef, wrapperRef: wrapperRefObject, tableRef: tableRefObject, onScroll: handleScroll, hasStickyColumns })
      )
    )
  );
});
var internal_default4 = InternalTable;

// node_modules/@cloudscape-design/components/table/index.js
var Table = import_react28.default.forwardRef((_a, ref) => {
  var { items = [], selectedItems = [], variant = "container", contentDensity = "comfortable" } = _a, props = __rest(_a, ["items", "selectedItems", "variant", "contentDensity"]);
  const baseComponentProps = useBaseComponent("Table", {
    props: {
      contentDensity,
      resizableColumns: props.resizableColumns,
      selectionType: props.selectionType,
      stickyHeader: props.stickyHeader,
      stripedRows: props.stripedRows,
      variant,
      wrapLines: props.wrapLines,
      enableKeyboardNavigation: props.enableKeyboardNavigation
    }
  });
  const tableProps = Object.assign(Object.assign(Object.assign({
    items,
    selectedItems,
    variant,
    contentDensity
  }, props), baseComponentProps), { ref });
  if (variant === "borderless" || variant === "embedded") {
    return import_react28.default.createElement(internal_default4, Object.assign({}, tableProps));
  }
  return import_react28.default.createElement(
    AnalyticsFunnelSubStep,
    null,
    import_react28.default.createElement(InternalTableAsSubstep, Object.assign({}, tableProps))
  );
});
applyDisplayName(Table, "Table");
var table_default = Table;

export {
  AsyncStore,
  useReaction,
  useSelector,
  ToolsHeader,
  getItemKey,
  SelectionControl,
  focusMarkers,
  useSelectionFocusMove,
  useSelection,
  stickyScrolling,
  useMouseDownTarget,
  internal_default4 as internal_default,
  table_default
};
//# sourceMappingURL=chunk-7VTKFCLZ.js.map
