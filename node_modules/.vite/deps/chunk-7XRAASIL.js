import {
  focus_lock_default
} from "./chunk-WS7XJ5RY.js";
import {
  calculateScroll,
  getFirstScrollableParent,
  scrollRectangleIntoView
} from "./chunk-4K34KLGB.js";
import {
  useInternalI18n
} from "./chunk-VCW6C342.js";
import {
  InternalButton
} from "./chunk-DPGYCRGF.js";
import {
  getContainingBlock
} from "./chunk-37SB7DJX.js";
import {
  useUniqueId
} from "./chunk-3TE4OIE4.js";
import {
  KeyCode,
  clsx_m_default,
  nodeContains,
  useResizeObserver,
  useVisualRefresh
} from "./chunk-CHBULPAM.js";
import {
  __toESM,
  require_react
} from "./chunk-S2TLTWWO.js";

// node_modules/@cloudscape-design/components/popover/styles.css.js
import "/home/bryanchasko/code/rgc3/node_modules/@cloudscape-design/components/popover/styles.scoped.css";
var styles_css_default = {
  "arrow": "awsui_arrow_xjuzf_ekpfy_197",
  "arrow-outer": "awsui_arrow-outer_xjuzf_ekpfy_201",
  "arrow-inner": "awsui_arrow-inner_xjuzf_ekpfy_201",
  "refresh": "awsui_refresh_xjuzf_ekpfy_231",
  "arrow-position-right-top": "awsui_arrow-position-right-top_xjuzf_ekpfy_241",
  "arrow-position-right-bottom": "awsui_arrow-position-right-bottom_xjuzf_ekpfy_241",
  "arrow-position-left-top": "awsui_arrow-position-left-top_xjuzf_ekpfy_244",
  "arrow-position-left-bottom": "awsui_arrow-position-left-bottom_xjuzf_ekpfy_244",
  "arrow-position-top-center": "awsui_arrow-position-top-center_xjuzf_ekpfy_247",
  "arrow-position-top-right": "awsui_arrow-position-top-right_xjuzf_ekpfy_247",
  "arrow-position-top-left": "awsui_arrow-position-top-left_xjuzf_ekpfy_247",
  "arrow-position-top-responsive": "awsui_arrow-position-top-responsive_xjuzf_ekpfy_247",
  "arrow-position-bottom-center": "awsui_arrow-position-bottom-center_xjuzf_ekpfy_250",
  "arrow-position-bottom-right": "awsui_arrow-position-bottom-right_xjuzf_ekpfy_250",
  "arrow-position-bottom-left": "awsui_arrow-position-bottom-left_xjuzf_ekpfy_250",
  "arrow-position-bottom-responsive": "awsui_arrow-position-bottom-responsive_xjuzf_ekpfy_250",
  "body": "awsui_body_xjuzf_ekpfy_352",
  "body-overflow-visible": "awsui_body-overflow-visible_xjuzf_ekpfy_391",
  "has-dismiss": "awsui_has-dismiss_xjuzf_ekpfy_395",
  "dismiss": "awsui_dismiss_xjuzf_ekpfy_400",
  "dismiss-control": "awsui_dismiss-control_xjuzf_ekpfy_408",
  "header-row": "awsui_header-row_xjuzf_ekpfy_412",
  "header": "awsui_header_xjuzf_ekpfy_412",
  "content": "awsui_content_xjuzf_ekpfy_438",
  "content-overflow-visible": "awsui_content-overflow-visible_xjuzf_ekpfy_446",
  "container": "awsui_container_xjuzf_ekpfy_548",
  "container-body": "awsui_container-body_xjuzf_ekpfy_556",
  "container-body-variant-annotation": "awsui_container-body-variant-annotation_xjuzf_ekpfy_599",
  "container-body-size-small": "awsui_container-body-size-small_xjuzf_ekpfy_604",
  "fixed-width": "awsui_fixed-width_xjuzf_ekpfy_607",
  "container-body-size-medium": "awsui_container-body-size-medium_xjuzf_ekpfy_611",
  "container-body-size-large": "awsui_container-body-size-large_xjuzf_ekpfy_618",
  "container-arrow": "awsui_container-arrow_xjuzf_ekpfy_630",
  "container-arrow-position-right-top": "awsui_container-arrow-position-right-top_xjuzf_ekpfy_634",
  "container-arrow-position-right-bottom": "awsui_container-arrow-position-right-bottom_xjuzf_ekpfy_634",
  "container-arrow-position-left-top": "awsui_container-arrow-position-left-top_xjuzf_ekpfy_646",
  "container-arrow-position-left-bottom": "awsui_container-arrow-position-left-bottom_xjuzf_ekpfy_646",
  "container-arrow-position-top-center": "awsui_container-arrow-position-top-center_xjuzf_ekpfy_658",
  "container-arrow-position-top-right": "awsui_container-arrow-position-top-right_xjuzf_ekpfy_658",
  "container-arrow-position-top-left": "awsui_container-arrow-position-top-left_xjuzf_ekpfy_658",
  "container-arrow-position-top-responsive": "awsui_container-arrow-position-top-responsive_xjuzf_ekpfy_658",
  "container-arrow-position-bottom-center": "awsui_container-arrow-position-bottom-center_xjuzf_ekpfy_674",
  "container-arrow-position-bottom-right": "awsui_container-arrow-position-bottom-right_xjuzf_ekpfy_678",
  "container-arrow-position-bottom-left": "awsui_container-arrow-position-bottom-left_xjuzf_ekpfy_682",
  "awsui-motion-fade-in": "awsui_awsui-motion-fade-in_xjuzf_ekpfy_1",
  "root": "awsui_root_xjuzf_ekpfy_828",
  "trigger": "awsui_trigger_xjuzf_ekpfy_864",
  "trigger-type-text": "awsui_trigger-type-text_xjuzf_ekpfy_871",
  "trigger-inner-text": "awsui_trigger-inner-text_xjuzf_ekpfy_906",
  "popover-content": "awsui_popover-content_xjuzf_ekpfy_910"
};

// node_modules/@cloudscape-design/components/popover/container.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/popover/use-popover-position.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/popover/utils/positions.js
var ARROW_OFFSET = 12;
var PRIORITY_MAPPING = {
  top: [
    "top-center",
    "top-right",
    "top-left",
    "bottom-center",
    "bottom-right",
    "bottom-left",
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom"
  ],
  bottom: [
    "bottom-center",
    "bottom-right",
    "bottom-left",
    "top-center",
    "top-right",
    "top-left",
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom"
  ],
  left: [
    "left-top",
    "left-bottom",
    "right-top",
    "right-bottom",
    "bottom-center",
    "top-center",
    "bottom-left",
    "top-left",
    "bottom-right",
    "top-right"
  ],
  right: [
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom",
    "bottom-center",
    "top-center",
    "bottom-right",
    "top-right",
    "bottom-left",
    "top-left"
  ]
};
var RECTANGLE_CALCULATIONS = {
  "top-center": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top - body.height - arrow.height,
      left: trigger.left + trigger.width / 2 - body.width / 2,
      width: body.width,
      height: body.height
    };
  },
  "top-right": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top - body.height - arrow.height,
      left: trigger.left + trigger.width / 2 - ARROW_OFFSET - arrow.width / 2,
      width: body.width,
      height: body.height
    };
  },
  "top-left": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top - body.height - arrow.height,
      left: trigger.left + trigger.width / 2 + ARROW_OFFSET + arrow.width / 2 - body.width,
      width: body.width,
      height: body.height
    };
  },
  "bottom-center": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height + arrow.height,
      left: trigger.left + trigger.width / 2 - body.width / 2,
      width: body.width,
      height: body.height
    };
  },
  "bottom-right": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height + arrow.height,
      left: trigger.left + trigger.width / 2 - ARROW_OFFSET - arrow.width / 2,
      width: body.width,
      height: body.height
    };
  },
  "bottom-left": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height + arrow.height,
      left: trigger.left + trigger.width / 2 + ARROW_OFFSET + arrow.width / 2 - body.width,
      width: body.width,
      height: body.height
    };
  },
  "right-top": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,
      left: trigger.left + trigger.width + arrow.height,
      width: body.width,
      height: body.height
    };
  },
  "right-bottom": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,
      left: trigger.left + trigger.width + arrow.height,
      width: body.width,
      height: body.height
    };
  },
  "left-top": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,
      left: trigger.left - body.width - arrow.height,
      width: body.width,
      height: body.height
    };
  },
  "left-bottom": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,
      left: trigger.left - body.width - arrow.height,
      width: body.width,
      height: body.height
    };
  }
};
function fitIntoContainer(inner, outer) {
  let { left, width, top, height } = inner;
  if (left < outer.left) {
    width = left + width - outer.left;
    left = outer.left;
  } else if (left + width > outer.left + outer.width) {
    width = outer.left + outer.width - left;
  }
  if (top < outer.top) {
    height = top + height - outer.top;
    top = outer.top;
  } else if (top + height > outer.top + outer.height) {
    height = outer.top + outer.height - top;
  }
  return { left, width, top, height };
}
function getTallestRect(rect1, rect2) {
  return rect1.height >= rect2.height ? rect1 : rect2;
}
function getIntersection(rectangles) {
  let boundingBox = null;
  for (const currentRect of rectangles) {
    if (!boundingBox) {
      boundingBox = currentRect;
      continue;
    }
    const left = Math.max(boundingBox.left, currentRect.left);
    const top = Math.max(boundingBox.top, currentRect.top);
    const right = Math.min(boundingBox.left + boundingBox.width, currentRect.left + currentRect.width);
    const bottom = Math.min(boundingBox.top + boundingBox.height, currentRect.top + currentRect.height);
    if (right < left || bottom < top) {
      return null;
    }
    boundingBox = {
      left,
      top,
      width: right - left,
      height: bottom - top
    };
  }
  return boundingBox;
}
function calculatePosition({
  preferredPosition,
  fixedInternalPosition,
  trigger,
  arrow,
  body,
  container,
  viewport,
  // the popover is only bound by the viewport if it is rendered in a portal
  renderWithPortal,
  allowVerticalOverflow
}) {
  let bestOption = null;
  const preferredInternalPositions = fixedInternalPosition ? [fixedInternalPosition] : PRIORITY_MAPPING[preferredPosition];
  for (const internalPosition2 of preferredInternalPositions) {
    const rect2 = RECTANGLE_CALCULATIONS[internalPosition2]({ body, trigger, arrow });
    const visibleArea = renderWithPortal ? getIntersection([rect2, viewport]) : getIntersection([rect2, viewport, container]);
    const fitsWithoutOverflow = visibleArea && visibleArea.width === body.width && visibleArea.height === body.height;
    if (fitsWithoutOverflow) {
      return { internalPosition: internalPosition2, rect: rect2 };
    }
    const newOption = { rect: rect2, internalPosition: internalPosition2, visibleArea };
    bestOption = getBestOption(newOption, bestOption);
  }
  const internalPosition = (bestOption === null || bestOption === void 0 ? void 0 : bestOption.internalPosition) || "right-top";
  const rect = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });
  const tallestBoundingContainer = getTallestRect(viewport, container);
  const boundingContainer = allowVerticalOverflow && isTopOrBottom(internalPosition) ? {
    top: tallestBoundingContainer.top,
    height: tallestBoundingContainer.height,
    left: viewport.left,
    width: viewport.width
  } : viewport;
  const optimizedRect = fitIntoContainer(rect, boundingContainer);
  const scrollable = optimizedRect.height < rect.height;
  return { internalPosition, rect: optimizedRect, scrollable };
}
function getBestOption(option1, option2) {
  if (!(option2 === null || option2 === void 0 ? void 0 : option2.visibleArea)) {
    return option1;
  }
  if (!option1.visibleArea) {
    return option2;
  }
  if (option1.visibleArea.width === option2.visibleArea.width) {
    return option1.visibleArea.height > option2.visibleArea.height ? option1 : option2;
  }
  return option1.visibleArea.width > option2.visibleArea.width ? option1 : option2;
}
function getOffsetDimensions(element) {
  return { offsetHeight: element.offsetHeight, offsetWidth: element.offsetWidth };
}
function getDimensions(element) {
  const computedStyle = getComputedStyle(element);
  return {
    width: parseFloat(computedStyle.width),
    height: parseFloat(computedStyle.height)
  };
}
function isTopOrBottom(internalPosition) {
  return ["top", "bottom"].includes(internalPosition.split("-")[0]);
}

// node_modules/@cloudscape-design/components/popover/use-popover-position.js
function usePopoverPosition({ popoverRef, bodyRef, arrowRef, trackRef, contentRef, allowScrollToFit, allowVerticalOverflow, preferredPosition, renderWithPortal, keepPosition }) {
  const previousInternalPositionRef = (0, import_react.useRef)(null);
  const [popoverStyle, setPopoverStyle] = (0, import_react.useState)({});
  const [internalPosition, setInternalPosition] = (0, import_react.useState)(null);
  const positionHandlerRef = (0, import_react.useRef)(() => {
  });
  const updatePositionHandler = (0, import_react.useCallback)((onContentResize = false) => {
    var _a;
    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {
      return;
    }
    const popover = popoverRef.current;
    const body = bodyRef.current;
    const arrow = arrowRef.current;
    const document = popover.ownerDocument;
    const track = trackRef.current;
    const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);
    if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {
      return;
    }
    const prevTop = popover.style.top;
    const prevLeft = popover.style.left;
    popover.style.top = "0";
    popover.style.left = "0";
    body.style.maxHeight = "";
    body.style.overflowX = "";
    body.style.overflowY = "";
    const viewportRect = getViewportRect(document.defaultView);
    const trackRect = track.getBoundingClientRect();
    const arrowRect = getDimensions(arrow);
    const containingBlock = getContainingBlock(popover);
    const containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect;
    const bodyBorderWidth = getBorderWidth(body);
    const contentRect = contentRef.current.getBoundingClientRect();
    const contentBoundingBox = {
      width: contentRect.width + 2 * bodyBorderWidth,
      height: contentRect.height + 2 * bodyBorderWidth
    };
    const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;
    const fixedInternalPosition = (_a = shouldKeepPosition && previousInternalPositionRef.current) !== null && _a !== void 0 ? _a : void 0;
    const { scrollable, internalPosition: newInternalPosition, rect } = calculatePosition({
      preferredPosition,
      fixedInternalPosition,
      trigger: trackRect,
      arrow: arrowRect,
      body: contentBoundingBox,
      container: containingBlock ? containingBlockRect : getDocumentRect(document),
      viewport: viewportRect,
      renderWithPortal,
      allowVerticalOverflow
    });
    const popoverOffset = toRelativePosition(rect, containingBlockRect);
    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));
    popover.style.top = prevTop;
    popover.style.left = prevLeft;
    if (scrollable) {
      body.style.maxHeight = rect.height + "px";
      body.style.overflowX = "hidden";
      body.style.overflowY = "auto";
    }
    previousInternalPositionRef.current = newInternalPosition;
    setInternalPosition(newInternalPosition);
    const shouldScroll = allowScrollToFit && !shouldKeepPosition;
    const top = shouldScroll ? popoverOffset.top + calculateScroll(rect) : popoverOffset.top;
    setPopoverStyle({ top, left: popoverOffset.left });
    if (shouldScroll) {
      const scrollableParent = getFirstScrollableParent(popover);
      scrollRectangleIntoView(rect, scrollableParent);
    }
    positionHandlerRef.current = () => {
      const newTrackOffset = toRelativePosition(track.getBoundingClientRect(), containingBlock ? containingBlock.getBoundingClientRect() : viewportRect);
      setPopoverStyle({
        top: newTrackOffset.top + trackRelativeOffset.top,
        left: newTrackOffset.left + trackRelativeOffset.left
      });
    };
  }, [
    trackRef,
    popoverRef,
    bodyRef,
    contentRef,
    arrowRef,
    keepPosition,
    allowScrollToFit,
    preferredPosition,
    renderWithPortal,
    allowVerticalOverflow
  ]);
  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef };
}
function getBorderWidth(element) {
  return parseInt(getComputedStyle(element).borderWidth) || 0;
}
function toRelativePosition(element, parent) {
  return {
    top: element.top - parent.top,
    left: element.left - parent.left
  };
}
function getViewportRect(window2) {
  return {
    top: 0,
    left: 0,
    width: window2.innerWidth,
    height: window2.innerHeight
  };
}
function getDocumentRect(document) {
  const { top, left } = document.documentElement.getBoundingClientRect();
  return {
    top,
    left,
    width: document.documentElement.scrollWidth,
    height: document.documentElement.scrollHeight
  };
}

// node_modules/@cloudscape-design/components/popover/container.js
function PopoverContainer({ position, trackRef, trackKey, arrow, children, zIndex, renderWithPortal, size, fixedWidth, variant, keepPosition, allowScrollToFit, allowVerticalOverflow }) {
  const bodyRef = (0, import_react2.useRef)(null);
  const contentRef = (0, import_react2.useRef)(null);
  const popoverRef = (0, import_react2.useRef)(null);
  const arrowRef = (0, import_react2.useRef)(null);
  const isRefresh = useVisualRefresh();
  const { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef } = usePopoverPosition({
    popoverRef,
    bodyRef,
    arrowRef,
    trackRef,
    contentRef,
    allowScrollToFit,
    allowVerticalOverflow,
    preferredPosition: position,
    renderWithPortal,
    keepPosition
  });
  (0, import_react2.useLayoutEffect)(() => {
    updatePositionHandler();
  }, [updatePositionHandler, trackKey]);
  useResizeObserver(contentRef, () => {
    updatePositionHandler(true);
  });
  (0, import_react2.useLayoutEffect)(() => {
    const onClick = (event) => {
      if (
        // Do not update position if keepPosition is true.
        keepPosition || // If the click was on the trigger, this will make the popover appear or disappear,
        // so no need to update its position either in this case.
        nodeContains(trackRef.current, event.target)
      ) {
        return;
      }
      requestAnimationFrame(() => {
        updatePositionHandler();
      });
    };
    const updatePositionOnResize = () => requestAnimationFrame(() => updatePositionHandler());
    const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());
    window.addEventListener("click", onClick);
    window.addEventListener("resize", updatePositionOnResize);
    window.addEventListener("scroll", refreshPosition, true);
    return () => {
      window.removeEventListener("click", onClick);
      window.removeEventListener("resize", updatePositionOnResize);
      window.removeEventListener("scroll", refreshPosition, true);
    };
  }, [keepPosition, positionHandlerRef, trackRef, updatePositionHandler]);
  return import_react2.default.createElement(
    "div",
    { ref: popoverRef, style: Object.assign(Object.assign({}, popoverStyle), { zIndex }), className: clsx_m_default(styles_css_default.container, isRefresh && styles_css_default.refresh) },
    import_react2.default.createElement("div", { ref: arrowRef, className: clsx_m_default(styles_css_default[`container-arrow`], styles_css_default[`container-arrow-position-${internalPosition}`]), "aria-hidden": true }, arrow(internalPosition)),
    import_react2.default.createElement(
      "div",
      { ref: bodyRef, className: clsx_m_default(styles_css_default["container-body"], styles_css_default[`container-body-size-${size}`], {
        [styles_css_default["fixed-width"]]: fixedWidth,
        [styles_css_default[`container-body-variant-${variant}`]]: variant
      }) },
      import_react2.default.createElement("div", { ref: contentRef }, children)
    )
  );
}

// node_modules/@cloudscape-design/components/popover/body.js
var import_react3 = __toESM(require_react());
function PopoverBody({ dismissButton: showDismissButton, dismissAriaLabel, header, children, onDismiss, variant, overflowVisible, className, ariaLabelledby }) {
  const i18n = useInternalI18n("popover");
  const labelledById = useUniqueId("awsui-popover-");
  const dismissButtonFocused = (0, import_react3.useRef)(false);
  const dismissButtonRef = (0, import_react3.useRef)(null);
  const onKeyDown = (0, import_react3.useCallback)((event) => {
    if (event.keyCode === KeyCode.escape) {
      event.stopPropagation();
      onDismiss();
    }
  }, [onDismiss]);
  (0, import_react3.useEffect)(() => {
    var _a;
    if (showDismissButton && !dismissButtonFocused.current) {
      (_a = dismissButtonRef.current) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
    }
    dismissButtonFocused.current = showDismissButton;
  }, [showDismissButton]);
  const dismissButton = (showDismissButton !== null && showDismissButton !== void 0 ? showDismissButton : null) && import_react3.default.createElement(
    "div",
    { className: styles_css_default.dismiss },
    import_react3.default.createElement(InternalButton, { variant: "icon", formAction: "none", iconName: "close", className: styles_css_default["dismiss-control"], ariaLabel: i18n("dismissAriaLabel", dismissAriaLabel), onClick: () => onDismiss(), ref: dismissButtonRef })
  );
  const isDialog = showDismissButton;
  const shouldTrapFocus = showDismissButton && variant !== "annotation";
  const dialogProps = isDialog ? {
    role: "dialog",
    "aria-modal": shouldTrapFocus ? true : void 0,
    "aria-labelledby": ariaLabelledby !== null && ariaLabelledby !== void 0 ? ariaLabelledby : header ? labelledById : void 0
  } : {};
  return import_react3.default.createElement(
    "div",
    Object.assign({ className: clsx_m_default(styles_css_default.body, className, {
      [styles_css_default["body-overflow-visible"]]: overflowVisible === "both"
    }), onKeyDown }, dialogProps),
    import_react3.default.createElement(
      focus_lock_default,
      { disabled: !shouldTrapFocus, autoFocus: false },
      header && import_react3.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default["header-row"], showDismissButton && styles_css_default["has-dismiss"]) },
        dismissButton,
        import_react3.default.createElement(
          "div",
          { className: styles_css_default.header, id: labelledById },
          import_react3.default.createElement("h2", null, header)
        )
      ),
      import_react3.default.createElement(
        "div",
        { className: !header && showDismissButton ? styles_css_default["has-dismiss"] : void 0 },
        !header && dismissButton,
        import_react3.default.createElement("div", { className: clsx_m_default(styles_css_default.content, { [styles_css_default["content-overflow-visible"]]: !!overflowVisible }) }, children)
      )
    )
  );
}

export {
  styles_css_default,
  PopoverContainer,
  PopoverBody
};
//# sourceMappingURL=chunk-7XRAASIL.js.map
